/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 61 generated on 2016-04-19 07:11:05.848527
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==61);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48;
x0=IKcos(j[4]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=(x1*x2);
x4=IKcos(j[1]);
x5=IKcos(j[0]);
x6=IKcos(j[2]);
x7=(x5*x6);
x8=(x4*x7);
x9=IKsin(j[4]);
x10=IKsin(j[1]);
x11=IKsin(j[3]);
x12=(x10*x11*x5);
x13=IKcos(j[3]);
x14=(x1*x6);
x15=(x2*x5);
x16=((1.0)*x15);
x17=(x14+(((-1.0)*(1.0)*x16*x4)));
x18=(((x13*x17))+(((-1.0)*(1.0)*x12)));
x19=IKcos(j[5]);
x20=((1.0)*x13);
x21=((((-1.0)*(1.0)*x10*x20*x5))+(((-1.0)*(1.0)*x11*x17)));
x22=IKsin(j[5]);
x23=((1.0)*x9);
x24=((1.0)*x3);
x25=((1.0)*x7);
x26=((((-1.0)*(1.0)*x24))+(((-1.0)*(1.0)*x25*x4)));
x27=(x0*x18);
x28=((0.00026931)*x10);
x29=((0.085)*x4);
x30=((0.06)*x4);
x31=((0.148)*x13);
x32=(x10*x6);
x33=(x0*x32);
x34=(x11*x4);
x35=((1.0)*x10*x2);
x36=(x34+(((-1.0)*(1.0)*x13*x35)));
x37=((1.0)*x4);
x38=(((x11*x35))+((x13*x37)));
x39=(x23*x32);
x40=(x0*x36);
x41=(x10*x2);
x42=(x16+(((-1.0)*(1.0)*x14*x37)));
x43=(x1*x10*x11);
x44=((1.0)*x43);
x45=((((-1.0)*(1.0)*x24*x4))+(((-1.0)*(1.0)*x25)));
x46=(((x11*x45))+((x1*x10*x13)));
x47=(x0*((((x13*x45))+(((-1.0)*(1.0)*x44)))));
x48=(x1*x4*x6);
eerot[0]=(((x18*x9))+((x0*((x8+x3)))));
eerot[1]=(((x22*(((((-1.0)*(1.0)*x23*x26))+(((-1.0)*(1.0)*x27))))))+((x19*x21)));
eerot[2]=(((x21*x22))+((x19*((((x26*x9))+x27)))));
eetrans[0]=(((x29*x5))+(((0.27)*x3))+(((0.27)*x8))+((x9*(((((-1.0)*(0.148)*x12))+((x17*x31))))))+((x0*(((((0.148)*x8))+(((0.148)*x3))))))+(((-1.0)*(1.0)*x15*x30))+((x28*x5))+(((0.27275298994736)*x1))+(((0.06)*x14)));
eerot[3]=(x33+((x36*x9)));
eerot[4]=(((x19*x38))+((x22*((x39+(((-1.0)*(1.0)*x40)))))));
eerot[5]=(((x19*(((((-1.0)*(1.0)*x39))+x40))))+((x22*x38)));
eetrans[1]=((((-1.0)*(0.06)*x41))+(((0.148)*x33))+(((-1.0)*(0.00026931)*x4))+((x9*(((((-1.0)*(1.0)*x31*x41))+(((0.148)*x34))))))+(((0.27)*x32))+(((0.085)*x10)));
eerot[6]=(((x9*(((((-1.0)*(1.0)*x20*x45))+x44))))+((x0*x42)));
eerot[7]=(((x19*x46))+((x22*((x47+((x42*x9)))))));
eerot[8]=(((x19*(((((-1.0)*(1.0)*x23*x42))+(((-1.0)*(1.0)*x47))))))+((x22*x46)));
IkReal x49=((1.0)*x1);
eetrans[2]=((0.136)+((x9*(((((-1.0)*(1.0)*x31*x45))+(((0.148)*x43))))))+(((0.06)*x7))+(((0.27275298994736)*x5))+(((-1.0)*x28*x49))+((x0*(((((-1.0)*(0.148)*x48))+(((0.148)*x15))))))+(((0.27)*x15))+(((-1.0)*x29*x49))+(((-1.0)*(0.27)*x48))+((x3*x30)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*(((1.0)*r01)));
new_r01=r02;
new_r02=((-1.0)*(((1.0)*r00)));
new_px=(px+(((-1.0)*(0.148)*r00)));
new_r10=r21;
new_r11=((-1.0)*(((1.0)*r22)));
new_r12=r20;
new_py=((0.136)+(((-1.0)*(1.0)*pz))+(((0.148)*r20)));
new_r20=((-1.0)*(((1.0)*r11)));
new_r21=r12;
new_r22=((-1.0)*(((1.0)*r10)));
new_pz=((((-1.0)*(0.148)*r10))+py);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x50=((1.0)*py);
IkReal x51=((1.0)*pz);
IkReal x52=((1.0)*px);
pp=((pz*pz)+(py*py)+(px*px));
npx=(((pz*r20))+((py*r10))+((px*r00)));
npy=(((pz*r21))+((py*r11))+((px*r01)));
npz=(((px*r02))+((pz*r22))+((py*r12)));
rxp0_0=((((-1.0)*r20*x50))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x51)));
rxp0_2=((((-1.0)*r10*x52))+((py*r00)));
rxp1_0=((((-1.0)*r21*x50))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x51)));
rxp1_2=(((py*r01))+(((-1.0)*r11*x52)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x50)));
rxp2_1=((((-1.0)*r02*x51))+((px*r22)));
rxp2_2=((((-1.0)*r12*x52))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x53=((-1.0)*(((1.0)*pp)));
IkReal x54=((0.54550597989472)*py);
IkReal x55=((((-1.0)*x54))+x53);
IkReal x56=((0.0552308790026515)+x55);
IkReal x57=((-0.0365691209973485)+x55);
IkReal x58=(x54+x53);
IkReal x59=((0.0552308790026515)+x58);
IkReal x60=((-0.0365691209973485)+x58);
IkReal gconst0=x56;
IkReal gconst1=x57;
IkReal gconst2=x56;
IkReal gconst3=x57;
IkReal gconst4=x59;
IkReal gconst5=x60;
IkReal gconst6=x59;
IkReal gconst7=x60;
IkReal x61=(gconst4*gconst6);
IkReal x62=((-0.0452638347315414)*x61);
IkReal x63=(gconst4*gconst7);
IkReal x64=((0.0707941935252246)*x63);
IkReal x65=(gconst5*gconst6);
IkReal x66=((-0.220805806474775)*x65);
IkReal x67=(gconst5*gconst7);
IkReal x68=((-0.110724552318908)*x67);
IkReal x69=py*py;
IkReal x70=(x63*x69);
IkReal x71=(x65*x69);
IkReal x72=(gconst4*gconst6*x69);
IkReal x73=((-1.0)*x72);
IkReal x74=(gconst5*gconst7*x69);
IkReal x75=((-1.0)*x74);
IkReal x76=((-1.0)*(((0.00366560693726012)*gconst5)));
IkReal x77=((-1.0)*(((0.00234368693726012)*gconst6)));
IkReal x78=((0.000227017768592987)*py);
IkReal x79=((0.011016)*py);
IkReal x80=(gconst5*x79);
IkReal x81=(gconst6*x79);
IkReal x82=((-0.00041616)*x69);
IkReal x83=((0.42550597989472)*py);
IkReal x84=(x61*x83);
IkReal x85=((0.54550597989472)*py);
IkReal x86=(x63*x85);
IkReal x87=(x65*x85);
IkReal x88=((0.66550597989472)*py);
IkReal x89=(x67*x88);
IkReal x90=((0.0223725354980809)*((px*py)));
IkReal x91=((0.85101195978944)*px);
IkReal x92=(x61*x91);
IkReal x93=((1.09101195978944)*px);
IkReal x94=((-1.0)*x63*x93);
IkReal x95=((-1.0)*x65*x93);
IkReal x96=((1.33101195978944)*px);
IkReal x97=(x67*x96);
IkReal x98=((-1.0)*(((0.00610217594980502)*px)));
IkReal x99=(gconst4*px);
IkReal x100=((0.0278539267816239)*x99);
IkReal x101=(gconst5*px);
IkReal x102=((-0.339671586477192)*x101);
IkReal x103=(gconst6*px);
IkReal x104=((-0.268253160692977)*x103);
IkReal x105=(gconst7*px);
IkReal x106=((-0.0435644990025918)*x105);
IkReal x107=((0.130921435174733)*py);
IkReal x108=(x107*x99);
IkReal x109=(x101*x107);
IkReal x110=(x103*x107);
IkReal x111=(x105*x107);
IkReal x112=((4.0)*px*py);
IkReal x113=(x112*x61);
IkReal x114=(x112*x63);
IkReal x115=(x112*x65);
IkReal x116=(x112*x67);
IkReal x117=(gconst1*x79);
IkReal x118=(gconst2*x79);
IkReal x119=px*px;
IkReal x120=((0.261842870349466)*x119);
IkReal x121=(((gconst5*x120))+(((-1.0)*(0.00703106081178035)*gconst6))+(((-1.0)*gconst4*x120))+(((-1.0)*gconst6*x120))+(((-1.0)*(0.0109968208117804)*gconst5))+((gconst7*x120))+x118+x117);
IkReal x122=((-1.0)*(((0.00366560693726012)*gconst1)));
IkReal x123=((-1.0)*(((0.00234368693726012)*gconst2)));
IkReal x124=((0.000454035537185973)*py);
IkReal x125=(gconst0*gconst6);
IkReal x126=((-0.0452638347315414)*x125);
IkReal x127=(gconst0*gconst7);
IkReal x128=((0.0707941935252246)*x127);
IkReal x129=(gconst1*gconst6);
IkReal x130=((-0.220805806474775)*x129);
IkReal x131=(gconst1*gconst7);
IkReal x132=((-0.110724552318908)*x131);
IkReal x133=(gconst2*gconst4);
IkReal x134=((-0.0452638347315414)*x133);
IkReal x135=(gconst2*gconst5);
IkReal x136=((-0.220805806474775)*x135);
IkReal x137=(gconst3*gconst4);
IkReal x138=((0.0707941935252246)*x137);
IkReal x139=(gconst3*gconst5);
IkReal x140=((-0.110724552318908)*x139);
IkReal x141=((-0.317824260503338)*x119);
IkReal x142=(x125*x83);
IkReal x143=(x127*x85);
IkReal x144=(x129*x85);
IkReal x145=(x131*x88);
IkReal x146=(x133*x83);
IkReal x147=(x135*x85);
IkReal x148=(x137*x85);
IkReal x149=(x139*x88);
IkReal x150=(x127*x69);
IkReal x151=(x129*x69);
IkReal x152=(x135*x69);
IkReal x153=(x137*x69);
IkReal x154=(gconst0*gconst6*x69);
IkReal x155=((-1.0)*x154);
IkReal x156=(gconst1*gconst7*x69);
IkReal x157=((-1.0)*x156);
IkReal x158=(gconst2*gconst4*x69);
IkReal x159=((-1.0)*x158);
IkReal x160=(gconst3*gconst5*x69);
IkReal x161=((-1.0)*x160);
IkReal x162=((4.0)*x119);
IkReal x163=(((x139*x96))+(((-1.0)*x127*x93))+((x125*x91))+(((-1.0)*(0.0183065278494151)*px))+(((-1.0)*x129*x93))+((x131*x96))+((x133*x91))+(((-1.0)*x135*x93))+(((-1.0)*x137*x93)));
IkReal x164=(gconst0*px);
IkReal x165=((0.0278539267816239)*x164);
IkReal x166=(gconst1*px);
IkReal x167=((-0.339671586477192)*x166);
IkReal x168=(gconst2*px);
IkReal x169=((-0.268253160692977)*x168);
IkReal x170=(gconst3*px);
IkReal x171=((-0.0435644990025918)*x170);
IkReal x172=(x107*x164);
IkReal x173=(x107*x166);
IkReal x174=(x107*x168);
IkReal x175=(x107*x170);
IkReal x176=(x112*x125);
IkReal x177=(x112*x127);
IkReal x178=(x112*x129);
IkReal x179=(x112*x131);
IkReal x180=(x112*x133);
IkReal x181=(x112*x135);
IkReal x182=(x112*x137);
IkReal x183=(x112*x139);
IkReal x184=((-1.0)*(((0.0109968208117804)*gconst1)));
IkReal x185=((-1.0)*(((0.00703106081178035)*gconst2)));
IkReal x186=(gconst0*gconst2);
IkReal x187=((-0.0452638347315414)*x186);
IkReal x188=(gconst0*gconst3);
IkReal x189=((0.0707941935252246)*x188);
IkReal x190=(gconst1*gconst2);
IkReal x191=((-0.220805806474775)*x190);
IkReal x192=(gconst1*gconst3);
IkReal x193=((-0.110724552318908)*x192);
IkReal x194=((-1.0)*x80);
IkReal x195=((-1.0)*x81);
IkReal x196=(x186*x83);
IkReal x197=(x188*x85);
IkReal x198=(x190*x85);
IkReal x199=(x192*x88);
IkReal x200=((-1.0)*gconst0*x120);
IkReal x201=(gconst1*x120);
IkReal x202=((-1.0)*gconst2*x120);
IkReal x203=(gconst3*x120);
IkReal x204=(x188*x69);
IkReal x205=(x190*x69);
IkReal x206=(gconst0*gconst2*x69);
IkReal x207=((-1.0)*x206);
IkReal x208=(gconst1*gconst3*x69);
IkReal x209=((-1.0)*x208);
IkReal x210=((-1.0)*x90);
IkReal x211=(x186*x91);
IkReal x212=((-1.0)*x188*x93);
IkReal x213=((-1.0)*x190*x93);
IkReal x214=(x192*x96);
IkReal x215=(x112*x186);
IkReal x216=(x112*x188);
IkReal x217=(x112*x190);
IkReal x218=(x112*x192);
IkReal x219=((-1.0)*x117);
IkReal x220=((-1.0)*x118);
op[0]=((-2.94617115774575e-5)+x68+x66+x64+x62+(((-1.0)*x86))+x81+x80+x84+x89+x82+(((-1.0)*x87))+x71+x70+x73+x75+x77+x76+x78);
op[1]=(x102+x106+x104+x100+x109+(((-1.0)*x110))+(((-1.0)*x113))+x98+x92+x95+x90+x94+x97+(((-1.0)*x116))+(((-1.0)*x108))+x115+x114+x111);
op[2]=((-0.00011784684630983)+x138+x130+x132+x136+x134+x128+x124+x126+x121+x122+x123+(((2.0)*x74))+x159+x150+x155+x157+x152+x151+x153+(((-1.0)*x148))+((x162*x63))+x149+x141+x142+x140+x145+x146+(((-2.0)*x70))+(((-0.0905276694630829)*x61))+(((-2.0)*x71))+(((2.0)*x72))+x81+x80+((x162*x65))+(((0.141588387050449)*x63))+(((-0.441611612949551)*x65))+(((-0.221449104637816)*x67))+(((-1.0)*x147))+x161+(((-1.0)*x162*x67))+(((-1.0)*x144))+(((-1.0)*x162*x61))+(((-1.0)*x143)));
op[3]=((((-1.0)*x174))+(((0.0557078535632477)*x99))+x92+x95+x90+x94+x97+(((-0.0871289980051836)*x105))+(((-0.536506321385954)*x103))+(((-1.0)*x179))+(((-1.0)*x176))+(((-1.0)*x172))+(((-1.0)*x114))+(((-1.0)*x183))+(((-1.0)*x115))+x173+x171+x178+x177+x175+(((-1.0)*x180))+x163+x165+x167+x169+(((-0.679343172954385)*x101))+x181+x182+x113+x116);
op[4]=((-0.000176770269464745)+(((2.0)*x158))+((x137*x162))+(((-1.0)*x197))+(((-1.0)*x139*x162))+(((2.0)*x160))+(((-1.0)*x131*x162))+x121+(((2.0)*x154))+(((-1.0)*x89))+(((-2.0)*x152))+((x127*x162))+(((-1.0)*x133*x162))+x68+x66+x64+x62+(((0.141588387050449)*x127))+(((-0.0905276694630829)*x133))+(((0.00083232)*x69))+(((-2.0)*x151))+(((-0.0905276694630829)*x125))+(((-1.0)*x125*x162))+(((-0.221449104637816)*x131))+(((-0.441611612949551)*x129))+(((-1.0)*x198))+x86+x87+(((-2.0)*x150))+(((-1.0)*x84))+(((-0.441611612949551)*x135))+((x135*x162))+(((-0.635648521006676)*x119))+x209+x204+x203+x205+x200+x202+x201+x207+x71+x70+x73+x75+(((-0.221449104637816)*x139))+x195+x194+x191+x193+x196+x199+(((0.141588387050449)*x137))+((x129*x162))+(((-2.0)*x153))+x189+x184+x187+x185+(((2.0)*x156)));
op[5]=(x102+x106+x104+x100+x108+(((-1.0)*x109))+(((-1.0)*x215))+(((-0.679343172954385)*x166))+(((-1.0)*x111))+(((-1.0)*x218))+(((-0.0871289980051836)*x170))+(((0.0557078535632477)*x164))+(((-1.0)*x178))+x213+x214+x211+x212+x217+x216+x210+(((-1.0)*x177))+x179+x176+(((-0.536506321385954)*x168))+x163+(((-1.0)*x182))+(((-1.0)*x181))+x183+x180+x110);
op[6]=((-0.00011784684630983)+(((-2.0)*x204))+x138+x130+x132+x136+x134+x128+x126+(((0.141588387050449)*x188))+x159+x150+x155+x157+x152+x151+x153+(((-0.0905276694630829)*x186))+(((-1.0)*x142))+(((2.0)*x206))+x147+x148+x141+x140+x143+x144+(((-1.0)*x162*x192))+(((2.0)*x208))+((x162*x188))+(((-1.0)*x146))+(((-1.0)*x124))+((x162*x190))+(((-2.0)*x205))+(((-1.0)*x145))+(((-1.0)*x162*x186))+x219+x203+x200+x202+x201+x77+x76+x161+x195+x194+x220+(((-0.441611612949551)*x190))+x184+x185+(((-0.221449104637816)*x192))+(((-1.0)*x149)));
op[7]=((((-1.0)*x216))+(((-1.0)*x175))+x98+(((-1.0)*x217))+(((-1.0)*x173))+x213+x214+x211+x212+x218+x215+x210+x172+x171+x174+x165+x167+x169);
op[8]=((-2.94617115774575e-5)+x122+x123+x82+(((-1.0)*x196))+x219+x209+x204+x205+x207+x191+x193+x197+x198+x220+(((-1.0)*x78))+x189+x187+(((-1.0)*x199)));
polyroots8(op,zeror,numroots);
IkReal j1array[8], cj1array[8], sj1array[8], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[8]={true,true,true,true,true,true,true,true};
_nj1 = 8;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x221=(cj1*py);
IkReal x222=(px*sj1);
if( IKabs(((-0.919608573504401)+(((-6.0461636904024)*x221))+(((-1.0)*(4.61361014994233)*pp))+(((6.0461636904024)*x222)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.407644585019529)+(((10.5410699401441)*x221))+(((20.7612456747405)*pp))+(((-10.5410699401441)*x222)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.919608573504401)+(((-6.0461636904024)*x221))+(((-1.0)*(4.61361014994233)*pp))+(((6.0461636904024)*x222))))+IKsqr(((-0.407644585019529)+(((10.5410699401441)*x221))+(((20.7612456747405)*pp))+(((-10.5410699401441)*x222))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.919608573504401)+(((-6.0461636904024)*x221))+(((-1.0)*(4.61361014994233)*pp))+(((6.0461636904024)*x222))), ((-0.407644585019529)+(((10.5410699401441)*x221))+(((20.7612456747405)*pp))+(((-10.5410699401441)*x222))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x223=(cj1*py);
IkReal x224=(px*sj1);
IkReal x225=IKsin(j3);
IkReal x226=IKcos(j3);
evalcond[0]=((0.27275298994736)+(((-1.0)*x224))+(((0.27)*x225))+x223+(((0.06)*x226)));
evalcond[1]=((0.00933087900265147)+(((-0.0102)*x225))+(((-0.54550597989472)*x223))+(((0.54550597989472)*x224))+(((-1.0)*(1.0)*pp))+(((0.0459)*x226)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[2];
IkReal x227=(cj3*sj3);
IkReal x228=cj3*cj3;
j2eval[0]=((1.06128162038001)+(((6.79411764705882)*x228))+(((-3.17647058823529)*x227))+(((4.5)*cj3))+(((-1.0)*(1.0)*sj3)));
j2eval[1]=IKsign(((108250725278761.0)+(((693000000000000.0)*x228))+(((-1.0)*(102000000000000.0)*sj3))+(((459000000000000.0)*cj3))+(((-324000000000000.0)*x227))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x229=py*py;
IkReal x230=cj1*cj1;
IkReal x231=((((-1.0)*x229*x230))+(((2.0)*cj1*px*py*sj1))+(pz*pz)+((x230*(px*px)))+x229);
j2eval[0]=x231;
j2eval[1]=IKsign(x231);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
j2eval[0]=((((-1.0)*(222.791578478334)*pz*sj3))+(((-1.0)*(1.0)*py*sj1))+(((315.621402844306)*pz))+(((1002.5621031525)*cj3*pz))+(((-1.0)*(1.0)*cj1*px)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x232=(cj1*px);
IkReal x233=(cj3*pz);
IkReal x234=(py*sj1);
IkReal x235=(pz*sj3);
IkReal x236=((100000000.0)*pz);
CheckValue<IkReal> x237=IKPowWithIntegerCheck(((((-2693100000000.0)*x232))+(((850000000000000.0)*pz))+(((-600000000000000.0)*x235))+(((2.7e+15)*x233))+(((-2693100000000.0)*x234))),-1);
if(!x237.valid){
continue;
}
CheckValue<IkReal> x238=IKPowWithIntegerCheck(((((27000000.0)*x233))+(((-6000000.0)*x235))+(((-26931.0)*x232))+(((8500000.0)*pz))+(((-26931.0)*x234))),-1);
if(!x238.valid){
continue;
}
if( IKabs(((x237.value)*(((-725278761.0)+(((1.0e+16)*(pz*pz))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x238.value)*(((-2289.135)+(((-1.0)*(7271.37)*cj3))+((x234*x236))+(((1615.86)*sj3))+((x232*x236)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x237.value)*(((-725278761.0)+(((1.0e+16)*(pz*pz)))))))+IKsqr(((x238.value)*(((-2289.135)+(((-1.0)*(7271.37)*cj3))+((x234*x236))+(((1615.86)*sj3))+((x232*x236))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x237.value)*(((-725278761.0)+(((1.0e+16)*(pz*pz)))))), ((x238.value)*(((-2289.135)+(((-1.0)*(7271.37)*cj3))+((x234*x236))+(((1615.86)*sj3))+((x232*x236))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x239=IKcos(j2);
IkReal x240=IKsin(j2);
IkReal x241=((1.0)*cj1*px);
IkReal x242=((1.0)*py*sj1);
IkReal x243=((1.0)*pz);
IkReal x244=((0.27)*cj3);
IkReal x245=((0.06)*sj3);
IkReal x246=((0.17)*x239);
evalcond[0]=((0.00026931)+(((-1.0)*x240*x242))+(((-1.0)*x240*x241))+((pz*x239)));
evalcond[1]=(((x240*x244))+(((-1.0)*x240*x245))+(((-1.0)*x243))+(((-0.00026931)*x239))+(((0.085)*x240)));
evalcond[2]=((0.085)+(((-1.0)*x240*x243))+(((-1.0)*x239*x242))+x244+(((-1.0)*x239*x241))+(((-1.0)*x245)));
evalcond[3]=((((-1.0)*x239*x245))+(((-1.0)*x242))+(((0.00026931)*x240))+((x239*x244))+(((0.085)*x239))+(((-1.0)*x241)));
evalcond[4]=((-0.00511912099734853)+((cj1*px*x246))+((py*sj1*x246))+(((-1.0)*(0.54550597989472)*cj1*py))+(((0.54550597989472)*px*sj1))+(((-1.0)*(1.0)*pp))+(((0.17)*pz*x240)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x910=py*py;
IkReal x911=(py*sj1);
IkReal x912=cj1*cj1;
IkReal x913=(cj1*px);
IkReal x914=((0.27)*cj3);
IkReal x915=((0.06)*sj3);
CheckValue<IkReal> x916=IKPowWithIntegerCheck(IKsign((x910+(pz*pz)+(((-1.0)*x910*x912))+(((2.0)*cj1*px*x911))+((x912*(px*px))))),-1);
if(!x916.valid){
continue;
}
CheckValue<IkReal> x917 = IKatan2WithCheck(IkReal(((((0.00026931)*x911))+(((0.085)*pz))+(((0.00026931)*x913))+(((-1.0)*pz*x915))+((pz*x914)))),(((x913*x914))+(((-1.0)*x911*x915))+(((-1.0)*x913*x915))+(((0.085)*x913))+((x911*x914))+(((0.085)*x911))+(((-1.0)*(0.00026931)*pz))),IKFAST_ATAN2_MAGTHRESH);
if(!x917.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x916.value)))+(x917.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x918=IKcos(j2);
IkReal x919=IKsin(j2);
IkReal x920=((1.0)*cj1*px);
IkReal x921=((1.0)*py*sj1);
IkReal x922=((1.0)*pz);
IkReal x923=((0.27)*cj3);
IkReal x924=((0.06)*sj3);
IkReal x925=((0.17)*x918);
evalcond[0]=((0.00026931)+(((-1.0)*x919*x921))+(((-1.0)*x919*x920))+((pz*x918)));
evalcond[1]=((((-0.00026931)*x918))+(((0.085)*x919))+((x919*x923))+(((-1.0)*x919*x924))+(((-1.0)*x922)));
evalcond[2]=((0.085)+(((-1.0)*x918*x920))+(((-1.0)*x924))+(((-1.0)*x918*x921))+x923+(((-1.0)*x919*x922)));
evalcond[3]=((((-1.0)*x921))+(((0.085)*x918))+((x918*x923))+(((-1.0)*x920))+(((0.00026931)*x919))+(((-1.0)*x918*x924)));
evalcond[4]=((-0.00511912099734853)+((cj1*px*x925))+(((0.17)*pz*x919))+((py*sj1*x925))+(((-1.0)*(0.54550597989472)*cj1*py))+(((0.54550597989472)*px*sj1))+(((-1.0)*(1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x926=(cj1*px);
IkReal x927=((2.7e+15)*cj3);
IkReal x928=(py*sj1);
IkReal x929=((600000000000000.0)*sj3);
CheckValue<IkReal> x930 = IKatan2WithCheck(IkReal(((((-1.0)*pz*x929))+(((2693100000000.0)*x926))+((pz*x927))+(((850000000000000.0)*pz))+(((2693100000000.0)*x928)))),((((-1.0)*x926*x929))+(((-1.0)*(2693100000000.0)*pz))+((x926*x927))+(((-1.0)*x928*x929))+(((850000000000000.0)*x926))+((x927*x928))+(((850000000000000.0)*x928))),IKFAST_ATAN2_MAGTHRESH);
if(!x930.valid){
continue;
}
CheckValue<IkReal> x931=IKPowWithIntegerCheck(IKsign(((108250725278761.0)+(((693000000000000.0)*(cj3*cj3)))+(((-1.0)*(102000000000000.0)*sj3))+(((-1.0)*(324000000000000.0)*cj3*sj3))+(((459000000000000.0)*cj3)))),-1);
if(!x931.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x930.value)+(((1.5707963267949)*(x931.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x932=IKcos(j2);
IkReal x933=IKsin(j2);
IkReal x934=((1.0)*cj1*px);
IkReal x935=((1.0)*py*sj1);
IkReal x936=((1.0)*pz);
IkReal x937=((0.27)*cj3);
IkReal x938=((0.06)*sj3);
IkReal x939=((0.17)*x932);
evalcond[0]=((0.00026931)+(((-1.0)*x933*x935))+(((-1.0)*x933*x934))+((pz*x932)));
evalcond[1]=((((-0.00026931)*x932))+(((-1.0)*x936))+((x933*x937))+(((-1.0)*x933*x938))+(((0.085)*x933)));
evalcond[2]=((0.085)+(((-1.0)*x932*x935))+(((-1.0)*x933*x936))+(((-1.0)*x938))+(((-1.0)*x932*x934))+x937);
evalcond[3]=(((x932*x937))+(((-1.0)*x934))+(((-1.0)*x932*x938))+(((0.00026931)*x933))+(((0.085)*x932))+(((-1.0)*x935)));
evalcond[4]=((-0.00511912099734853)+((py*sj1*x939))+(((-1.0)*(0.54550597989472)*cj1*py))+((cj1*px*x939))+(((0.17)*pz*x933))+(((0.54550597989472)*px*sj1))+(((-1.0)*(1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x247=((1.0)*cj2);
IkReal x248=(cj1*sj2);
IkReal x249=(sj1*sj2);
IkReal x250=((1.0)*sj2*sj3);
IkReal x251=(cj3*sj1);
IkReal x252=(cj1*sj3);
IkReal x253=(x251+(((-1.0)*x247*x252)));
IkReal x254=((1.0)*cj1*cj3);
IkReal x255=(sj1*sj3);
IkReal x256=((((-1.0)*x247*x255))+(((-1.0)*x254)));
IkReal x257=((1.0)*cj3*sj2);
IkReal x258=((((-1.0)*x247*x251))+x252);
IkReal x259=((((-1.0)*cj2*x254))+(((-1.0)*x255)));
new_r00=((((-1.0)*r20*x247))+((r10*x249))+((r00*x248)));
new_r01=(((r11*x249))+(((-1.0)*r21*x247))+((r01*x248)));
new_r02=(((r12*x249))+((r02*x248))+(((-1.0)*r22*x247)));
new_r10=(((r10*x256))+((r00*x253))+(((-1.0)*r20*x250)));
new_r11=(((r11*x256))+(((-1.0)*r21*x250))+((r01*x253)));
new_r12=(((r12*x256))+((r02*x253))+(((-1.0)*r22*x250)));
new_r20=(((r00*x259))+(((-1.0)*r20*x257))+((r10*x258)));
new_r21=(((r01*x259))+(((-1.0)*r21*x257))+((r11*x258)));
new_r22=(((r02*x259))+((r12*x258))+(((-1.0)*r22*x257)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j6eval[3];
IkReal x260=((1.0)*cj2);
IkReal x261=(cj1*sj2);
IkReal x262=(sj1*sj2);
IkReal x263=((1.0)*sj2*sj3);
IkReal x264=(cj3*sj1);
IkReal x265=(cj1*sj3);
IkReal x266=(x264+(((-1.0)*x260*x265)));
IkReal x267=((1.0)*cj1*cj3);
IkReal x268=(sj1*sj3);
IkReal x269=x256;
IkReal x270=((1.0)*cj3*sj2);
IkReal x271=(x265+(((-1.0)*x260*x264)));
IkReal x272=x259;
new_r00=(((r10*x262))+((r00*x261))+(((-1.0)*r20*x260)));
new_r01=(((r11*x262))+((r01*x261))+(((-1.0)*r21*x260)));
new_r02=(((r02*x261))+((r12*x262))+(((-1.0)*r22*x260)));
new_r10=((((-1.0)*r20*x263))+((r00*x266))+((r10*x269)));
new_r11=(((r01*x266))+(((-1.0)*r21*x263))+((r11*x269)));
new_r12=(((r02*x266))+(((-1.0)*r22*x263))+((r12*x269)));
new_r20=(((r10*x271))+((r00*x272))+(((-1.0)*r20*x270)));
new_r21=((((-1.0)*r21*x270))+((r01*x272))+((r11*x271)));
new_r22=((((-1.0)*r22*x270))+((r12*x271))+((r02*x272)));
IkReal x273=(cj1*sj3);
IkReal x274=((1.0)*cj3*sj2);
IkReal x275=((1.0)*sj1*sj3);
IkReal x276=((1.0)*cj1*cj2*cj3);
IkReal x277=((1.0)*cj2*cj3*sj1);
j6eval[0]=sj5;
j6eval[1]=((IKabs((((r11*x273))+(((-1.0)*r01*x276))+(((-1.0)*r21*x274))+(((-1.0)*r11*x277))+(((-1.0)*r01*x275)))))+(IKabs(((((-1.0)*r10*x277))+(((-1.0)*r00*x275))+((r10*x273))+(((-1.0)*r00*x276))+(((-1.0)*r20*x274))))));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
IkReal x278=((1.0)*cj2);
IkReal x279=(cj1*sj2);
IkReal x280=(sj1*sj2);
IkReal x281=((1.0)*sj2*sj3);
IkReal x282=(cj3*sj1);
IkReal x283=(cj1*sj3);
IkReal x284=((((-1.0)*x278*x283))+x282);
IkReal x285=((1.0)*cj1*cj3);
IkReal x286=(sj1*sj3);
IkReal x287=x256;
IkReal x288=((1.0)*cj3*sj2);
IkReal x289=((((-1.0)*x278*x282))+x283);
IkReal x290=x259;
new_r00=((((-1.0)*r20*x278))+((r00*x279))+((r10*x280)));
new_r01=((((-1.0)*r21*x278))+((r11*x280))+((r01*x279)));
new_r02=(((r02*x279))+((r12*x280))+(((-1.0)*r22*x278)));
new_r10=(((r00*x284))+(((-1.0)*r20*x281))+((r10*x287)));
new_r11=(((r01*x284))+(((-1.0)*r21*x281))+((r11*x287)));
new_r12=(((r02*x284))+(((-1.0)*r22*x281))+((r12*x287)));
new_r20=(((r00*x290))+(((-1.0)*r20*x288))+((r10*x289)));
new_r21=(((r11*x289))+(((-1.0)*r21*x288))+((r01*x290)));
new_r22=(((r12*x289))+((r02*x290))+(((-1.0)*r22*x288)));
IkReal x291=(cj1*r02);
IkReal x292=(r12*sj1);
IkReal x293=(cj2*sj3);
j4eval[0]=sj5;
j4eval[1]=IKsign(sj5);
j4eval[2]=((IKabs(((((-1.0)*(1.0)*cj2*r22))+((sj2*x292))+((sj2*x291)))))+(IKabs((((x292*x293))+((r22*sj2*sj3))+((cj1*cj3*r12))+((x291*x293))+(((-1.0)*(1.0)*cj3*r02*sj1))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x294=((1.0)*cj2);
IkReal x295=(cj1*sj2);
IkReal x296=(sj1*sj2);
IkReal x297=((1.0)*sj2*sj3);
IkReal x298=(cj3*sj1);
IkReal x299=(cj1*sj3);
IkReal x300=(x298+(((-1.0)*x294*x299)));
IkReal x301=((1.0)*cj1*cj3);
IkReal x302=(sj1*sj3);
IkReal x303=x256;
IkReal x304=((1.0)*cj3*sj2);
IkReal x305=(x299+(((-1.0)*x294*x298)));
IkReal x306=x259;
new_r00=((((-1.0)*r20*x294))+((r00*x295))+((r10*x296)));
new_r01=(((r01*x295))+((r11*x296))+(((-1.0)*r21*x294)));
new_r02=(((r12*x296))+((r02*x295))+(((-1.0)*r22*x294)));
new_r10=(((r10*x303))+((r00*x300))+(((-1.0)*r20*x297)));
new_r11=(((r11*x303))+((r01*x300))+(((-1.0)*r21*x297)));
new_r12=(((r12*x303))+((r02*x300))+(((-1.0)*r22*x297)));
new_r20=(((r00*x306))+(((-1.0)*r20*x304))+((r10*x305)));
new_r21=((((-1.0)*r21*x304))+((r11*x305))+((r01*x306)));
new_r22=(((r02*x306))+(((-1.0)*r22*x304))+((r12*x305)));
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x307=((1.0)*cj2);
IkReal x308=(cj1*sj2);
IkReal x309=(sj1*sj2);
IkReal x310=((1.0)*sj2*sj3);
IkReal x311=(cj3*sj1);
IkReal x312=(cj1*sj3);
IkReal x313=((((-1.0)*x307*x312))+x311);
IkReal x314=((1.0)*cj1*cj3);
IkReal x315=(sj1*sj3);
IkReal x316=x256;
IkReal x317=((1.0)*cj3*sj2);
IkReal x318=(x312+(((-1.0)*x307*x311)));
IkReal x319=x259;
sj5=0;
cj5=1.0;
j5=0;
new_r00=(((r00*x308))+(((-1.0)*r20*x307))+((r10*x309)));
new_r01=((((-1.0)*r21*x307))+((r01*x308))+((r11*x309)));
new_r02=(((r12*x309))+((r02*x308))+(((-1.0)*r22*x307)));
new_r10=(((r10*x316))+(((-1.0)*r20*x310))+((r00*x313)));
new_r11=(((r01*x313))+((r11*x316))+(((-1.0)*r21*x310)));
new_r12=(((r12*x316))+(((-1.0)*r22*x310))+((r02*x313)));
new_r20=((((-1.0)*r20*x317))+((r10*x318))+((r00*x319)));
new_r21=(((r11*x318))+((r01*x319))+(((-1.0)*r21*x317)));
new_r22=(((r12*x318))+((r02*x319))+(((-1.0)*r22*x317)));
IkReal x320=((1.0)*r22);
IkReal x321=(cj1*r02);
IkReal x322=(r12*sj1);
IkReal x323=((1.0)*cj2*sj3);
j4eval[0]=((IKabs(((((-1.0)*cj2*x320))+((sj2*x321))+((sj2*x322)))))+(IKabs(((((-1.0)*sj2*sj3*x320))+(((-1.0)*x322*x323))+(((-1.0)*x321*x323))+((cj3*r02*sj1))+(((-1.0)*(1.0)*cj1*cj3*r12))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x324=((1.0)*cj2);
IkReal x325=(cj1*sj2);
IkReal x326=(sj1*sj2);
IkReal x327=((1.0)*sj2*sj3);
IkReal x328=(cj3*sj1);
IkReal x329=(cj1*sj3);
IkReal x330=((((-1.0)*x324*x329))+x328);
IkReal x331=((1.0)*cj1*cj3);
IkReal x332=(sj1*sj3);
IkReal x333=x256;
IkReal x334=((1.0)*cj3*sj2);
IkReal x335=(x329+(((-1.0)*x324*x328)));
IkReal x336=x259;
sj5=0;
cj5=1.0;
j5=0;
new_r00=(((r10*x326))+((r00*x325))+(((-1.0)*r20*x324)));
new_r01=((((-1.0)*r21*x324))+((r01*x325))+((r11*x326)));
new_r02=(((r02*x325))+((r12*x326))+(((-1.0)*r22*x324)));
new_r10=(((r00*x330))+((r10*x333))+(((-1.0)*r20*x327)));
new_r11=((((-1.0)*r21*x327))+((r01*x330))+((r11*x333)));
new_r12=(((r02*x330))+((r12*x333))+(((-1.0)*r22*x327)));
new_r20=((((-1.0)*r20*x334))+((r10*x335))+((r00*x336)));
new_r21=(((r01*x336))+((r11*x335))+(((-1.0)*r21*x334)));
new_r22=((((-1.0)*r22*x334))+((r12*x335))+((r02*x336)));
IkReal x337=((1.0)*cj1*r02);
IkReal x338=((1.0)*sj2);
IkReal x339=(cj2*sj3);
j4eval[0]=((IKabs(((((-1.0)*r22*sj3*x338))+(((-1.0)*r12*sj1*x339))+(((-1.0)*cj1*cj3*r12))+(((-1.0)*x337*x339))+((cj3*r02*sj1)))))+(IKabs((((cj2*r22))+(((-1.0)*sj2*x337))+(((-1.0)*r12*sj1*x338))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4, j6]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x341 = IKatan2WithCheck(IkReal(new_r12),((-1.0)*(((1.0)*new_r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x341.valid){
continue;
}
IkReal x340=((-1.0)*(x341.value));
j4array[0]=x340;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+x340);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r02*(IKcos(j4))))+((new_r12*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x342=((1.0)*new_r01);
if( IKabs(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x342)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x342)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x342))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x342))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x342))), (((cj4*new_r00))+(((-1.0)*sj4*x342))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x343=IKsin(j6);
IkReal x344=IKcos(j6);
IkReal x345=((1.0)*x344);
IkReal x346=((-1.0)*x345);
IkReal x347=(cj4*x343);
IkReal x348=(((sj4*x343))+(((-1.0)*cj4*x345)));
IkReal x349=((1.0)*sj4);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x343);
evalcond[1]=(((cj4*new_r00))+((new_r10*sj4))+x346);
evalcond[2]=(((sj4*x344))+x347+new_r01);
evalcond[3]=(x348+new_r00);
evalcond[4]=(new_r11+x348);
evalcond[5]=((((-1.0)*new_r00*x349))+((cj4*new_r10))+(((-1.0)*x343)));
evalcond[6]=((((-1.0)*new_r01*x349))+((cj4*new_r11))+x346);
evalcond[7]=((((-1.0)*x347))+(((-1.0)*x344*x349))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x351 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x351.valid){
continue;
}
IkReal x350=((-1.0)*(((1.0)*(x351.value))));
j4array[0]=x350;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+x350);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*new_r02*(IKsin(j4))))+((new_r12*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x352=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x352))+(((-1.0)*(1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x352))+((cj4*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x352))+(((-1.0)*(1.0)*new_r00*sj4))))+IKsqr(((((-1.0)*sj4*x352))+((cj4*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x352))+(((-1.0)*(1.0)*new_r00*sj4))), ((((-1.0)*sj4*x352))+((cj4*new_r00))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x353=IKsin(j6);
IkReal x354=IKcos(j6);
IkReal x355=((1.0)*x354);
IkReal x356=((-1.0)*x355);
IkReal x357=(cj4*x353);
IkReal x358=(((sj4*x353))+(((-1.0)*cj4*x355)));
IkReal x359=((1.0)*sj4);
evalcond[0]=(((cj4*new_r01))+x353+((new_r11*sj4)));
evalcond[1]=(x356+((cj4*new_r00))+((new_r10*sj4)));
evalcond[2]=(x357+((sj4*x354))+new_r01);
evalcond[3]=(x358+new_r00);
evalcond[4]=(x358+new_r11);
evalcond[5]=(((cj4*new_r10))+(((-1.0)*new_r00*x359))+(((-1.0)*x353)));
evalcond[6]=(x356+(((-1.0)*new_r01*x359))+((cj4*new_r11)));
evalcond[7]=((((-1.0)*x357))+new_r10+(((-1.0)*x354*x359)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
IkReal x360=((1.0)*cj2);
IkReal x361=(cj1*sj2);
IkReal x362=(sj1*sj2);
IkReal x363=((1.0)*sj2*sj3);
IkReal x364=(cj3*sj1);
IkReal x365=(cj1*sj3);
IkReal x366=(x364+(((-1.0)*x360*x365)));
IkReal x367=((1.0)*cj1*cj3);
IkReal x368=(sj1*sj3);
IkReal x369=x256;
IkReal x370=((1.0)*cj3*sj2);
IkReal x371=((((-1.0)*x360*x364))+x365);
IkReal x372=x259;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r00=((((-1.0)*r20*x360))+((r00*x361))+((r10*x362)));
new_r01=(((r01*x361))+((r11*x362))+(((-1.0)*r21*x360)));
new_r02=(((r02*x361))+((r12*x362))+(((-1.0)*r22*x360)));
new_r10=((((-1.0)*r20*x363))+((r00*x366))+((r10*x369)));
new_r11=(((r11*x369))+(((-1.0)*r21*x363))+((r01*x366)));
new_r12=(((r12*x369))+(((-1.0)*r22*x363))+((r02*x366)));
new_r20=((((-1.0)*r20*x370))+((r10*x371))+((r00*x372)));
new_r21=(((r01*x372))+(((-1.0)*r21*x370))+((r11*x371)));
new_r22=(((r02*x372))+((r12*x371))+(((-1.0)*r22*x370)));
IkReal x373=((1.0)*r22);
IkReal x374=(cj1*r02);
IkReal x375=(r12*sj1);
IkReal x376=((1.0)*cj2*sj3);
j4eval[0]=((IKabs((((sj2*x374))+(((-1.0)*cj2*x373))+((sj2*x375)))))+(IKabs(((((-1.0)*x375*x376))+(((-1.0)*sj2*sj3*x373))+((cj3*r02*sj1))+(((-1.0)*x374*x376))+(((-1.0)*(1.0)*cj1*cj3*r12))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x377=((1.0)*cj2);
IkReal x378=(cj1*sj2);
IkReal x379=(sj1*sj2);
IkReal x380=((1.0)*sj2*sj3);
IkReal x381=(cj3*sj1);
IkReal x382=(cj1*sj3);
IkReal x383=((((-1.0)*x377*x382))+x381);
IkReal x384=((1.0)*cj1*cj3);
IkReal x385=(sj1*sj3);
IkReal x386=x256;
IkReal x387=((1.0)*cj3*sj2);
IkReal x388=((((-1.0)*x377*x381))+x382);
IkReal x389=x259;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r00=(((r10*x379))+((r00*x378))+(((-1.0)*r20*x377)));
new_r01=(((r11*x379))+((r01*x378))+(((-1.0)*r21*x377)));
new_r02=((((-1.0)*r22*x377))+((r02*x378))+((r12*x379)));
new_r10=(((r10*x386))+(((-1.0)*r20*x380))+((r00*x383)));
new_r11=(((r01*x383))+((r11*x386))+(((-1.0)*r21*x380)));
new_r12=(((r12*x386))+(((-1.0)*r22*x380))+((r02*x383)));
new_r20=(((r00*x389))+(((-1.0)*r20*x387))+((r10*x388)));
new_r21=(((r01*x389))+((r11*x388))+(((-1.0)*r21*x387)));
new_r22=(((r02*x389))+(((-1.0)*r22*x387))+((r12*x388)));
IkReal x390=((1.0)*cj1*r02);
IkReal x391=((1.0)*sj2);
IkReal x392=(cj2*sj3);
j4eval[0]=((IKabs(((((-1.0)*r12*sj1*x392))+(((-1.0)*cj1*cj3*r12))+(((-1.0)*r22*sj3*x391))+(((-1.0)*x390*x392))+((cj3*r02*sj1)))))+(IKabs((((cj2*r22))+(((-1.0)*sj2*x390))+(((-1.0)*r12*sj1*x391))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4, j6]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x394 = IKatan2WithCheck(IkReal(new_r12),((-1.0)*(((1.0)*new_r02))),IKFAST_ATAN2_MAGTHRESH);
if(!x394.valid){
continue;
}
IkReal x393=((-1.0)*(x394.value));
j4array[0]=x393;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+x393);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r02*(IKcos(j4))))+((new_r12*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x395=((1.0)*cj4);
if( IKabs(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x395)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x395))+((new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x395))))+IKsqr(((((-1.0)*new_r11*x395))+((new_r01*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x395))), ((((-1.0)*new_r11*x395))+((new_r01*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x396=IKsin(j6);
IkReal x397=((1.0)*sj4);
IkReal x398=IKcos(j6);
IkReal x399=(cj4*x398);
IkReal x400=(((cj4*x396))+(((-1.0)*x397*x398)));
evalcond[0]=(x396+((cj4*new_r01))+((new_r11*sj4)));
evalcond[1]=(x396+((cj4*new_r10))+(((-1.0)*new_r00*x397)));
evalcond[2]=(x398+(((-1.0)*new_r01*x397))+((cj4*new_r11)));
evalcond[3]=((((-1.0)*x398))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(x399+((sj4*x396))+new_r11);
evalcond[5]=(x400+new_r01);
evalcond[6]=(x400+new_r10);
evalcond[7]=((((-1.0)*x399))+(((-1.0)*x396*x397))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x402 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x402.valid){
continue;
}
IkReal x401=((-1.0)*(((1.0)*(x402.value))));
j4array[0]=x401;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+x401);
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*new_r02*(IKsin(j4))))+((new_r12*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x403=((1.0)*cj4);
if( IKabs(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x403)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x403))+((new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x403))))+IKsqr(((((-1.0)*new_r11*x403))+((new_r01*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x403))), ((((-1.0)*new_r11*x403))+((new_r01*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x404=IKsin(j6);
IkReal x405=((1.0)*sj4);
IkReal x406=IKcos(j6);
IkReal x407=(cj4*x406);
IkReal x408=(((cj4*x404))+(((-1.0)*x405*x406)));
evalcond[0]=(((cj4*new_r01))+x404+((new_r11*sj4)));
evalcond[1]=(((cj4*new_r10))+x404+(((-1.0)*new_r00*x405)));
evalcond[2]=((((-1.0)*new_r01*x405))+x406+((cj4*new_r11)));
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x406)));
evalcond[4]=(((sj4*x404))+x407+new_r11);
evalcond[5]=(x408+new_r01);
evalcond[6]=(x408+new_r10);
evalcond[7]=((((-1.0)*x404*x405))+new_r00+(((-1.0)*x407)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x410=IKPowWithIntegerCheck(sj5,-1);
if(!x410.valid){
continue;
}
IkReal x409=x410.value;
CheckValue<IkReal> x411=IKPowWithIntegerCheck(new_r02,-1);
if(!x411.valid){
continue;
}
if( IKabs((x409*(x411.value)*(((1.0)+(((-1.0)*(1.0)*(cj5*cj5)))+(((-1.0)*(1.0)*(new_r12*new_r12))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x409)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x409*(x411.value)*(((1.0)+(((-1.0)*(1.0)*(cj5*cj5)))+(((-1.0)*(1.0)*(new_r12*new_r12)))))))+IKsqr(((-1.0)*new_r12*x409))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x409*(x411.value)*(((1.0)+(((-1.0)*(1.0)*(cj5*cj5)))+(((-1.0)*(1.0)*(new_r12*new_r12)))))), ((-1.0)*new_r12*x409));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x412=IKcos(j4);
IkReal x413=(sj5*x412);
IkReal x414=IKsin(j4);
IkReal x415=((1.0)*x414);
IkReal x416=(sj5*x415);
IkReal x417=(new_r12*x412);
IkReal x418=(new_r02*x415);
IkReal x419=((1.0)*cj5);
evalcond[0]=(x413+new_r12);
evalcond[1]=((((-1.0)*x416))+new_r02);
evalcond[2]=(((new_r02*x412))+((new_r12*x414)));
evalcond[3]=((((-1.0)*x418))+x417+sj5);
evalcond[4]=(((new_r22*sj5))+((cj5*x417))+(((-1.0)*new_r02*x414*x419)));
evalcond[5]=((((-1.0)*new_r20*x419))+((new_r10*x413))+(((-1.0)*new_r00*x416)));
evalcond[6]=(((new_r11*x413))+(((-1.0)*new_r01*x416))+(((-1.0)*new_r21*x419)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x419))+((sj5*x417))+(((-1.0)*sj5*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
IkReal x420=((1.0)*cj2);
IkReal x421=(cj1*sj2);
IkReal x422=(sj1*sj2);
IkReal x423=((1.0)*sj2*sj3);
IkReal x424=(cj3*sj1);
IkReal x425=(cj1*sj3);
IkReal x426=((((-1.0)*x420*x425))+x424);
IkReal x427=((1.0)*cj1*cj3);
IkReal x428=(sj1*sj3);
IkReal x429=x256;
IkReal x430=((1.0)*cj3*sj2);
IkReal x431=(x425+(((-1.0)*x420*x424)));
IkReal x432=x259;
new_r00=(((r10*x422))+(((-1.0)*r20*x420))+((r00*x421)));
new_r01=((((-1.0)*r21*x420))+((r01*x421))+((r11*x422)));
new_r02=((((-1.0)*r22*x420))+((r12*x422))+((r02*x421)));
new_r10=(((r00*x426))+((r10*x429))+(((-1.0)*r20*x423)));
new_r11=((((-1.0)*r21*x423))+((r11*x429))+((r01*x426)));
new_r12=(((r02*x426))+(((-1.0)*r22*x423))+((r12*x429)));
new_r20=(((r00*x432))+(((-1.0)*r20*x430))+((r10*x431)));
new_r21=(((r11*x431))+((r01*x432))+(((-1.0)*r21*x430)));
new_r22=(((r02*x432))+((r12*x431))+(((-1.0)*r22*x430)));
IkReal x433=(cj1*sj3);
IkReal x434=((1.0)*cj3*sj2);
IkReal x435=((1.0)*sj1*sj3);
IkReal x436=((1.0)*cj1*cj2*cj3);
IkReal x437=((1.0)*cj2*cj3*sj1);
j6eval[0]=sj5;
j6eval[1]=((IKabs(((((-1.0)*r01*x435))+(((-1.0)*r21*x434))+(((-1.0)*r01*x436))+(((-1.0)*r11*x437))+((r11*x433)))))+(IKabs(((((-1.0)*r00*x435))+((r10*x433))+(((-1.0)*r20*x434))+(((-1.0)*r10*x437))+(((-1.0)*r00*x436))))));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x438=((1.0)*cj2);
IkReal x439=(cj1*sj2);
IkReal x440=(sj1*sj2);
IkReal x441=((1.0)*sj2*sj3);
IkReal x442=(cj3*sj1);
IkReal x443=(cj1*sj3);
IkReal x444=(x442+(((-1.0)*x438*x443)));
IkReal x445=((1.0)*cj1*cj3);
IkReal x446=(sj1*sj3);
IkReal x447=x256;
IkReal x448=((1.0)*cj3*sj2);
IkReal x449=((((-1.0)*x438*x442))+x443);
IkReal x450=x259;
new_r00=(((r10*x440))+(((-1.0)*r20*x438))+((r00*x439)));
new_r01=(((r11*x440))+((r01*x439))+(((-1.0)*r21*x438)));
new_r02=(((r02*x439))+((r12*x440))+(((-1.0)*r22*x438)));
new_r10=((((-1.0)*r20*x441))+((r00*x444))+((r10*x447)));
new_r11=((((-1.0)*r21*x441))+((r11*x447))+((r01*x444)));
new_r12=((((-1.0)*r22*x441))+((r02*x444))+((r12*x447)));
new_r20=(((r10*x449))+(((-1.0)*r20*x448))+((r00*x450)));
new_r21=(((r01*x450))+((r11*x449))+(((-1.0)*r21*x448)));
new_r22=(((r02*x450))+((r12*x449))+(((-1.0)*r22*x448)));
j6eval[0]=sj5;
j6eval[1]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x451=((1.0)*cj2);
IkReal x452=(cj1*sj2);
IkReal x453=(sj1*sj2);
IkReal x454=((1.0)*sj2*sj3);
IkReal x455=(cj3*sj1);
IkReal x456=(cj1*sj3);
IkReal x457=(x455+(((-1.0)*x451*x456)));
IkReal x458=((1.0)*cj1*cj3);
IkReal x459=(sj1*sj3);
IkReal x460=x256;
IkReal x461=((1.0)*cj3*sj2);
IkReal x462=((((-1.0)*x451*x455))+x456);
IkReal x463=x259;
new_r00=((((-1.0)*r20*x451))+((r00*x452))+((r10*x453)));
new_r01=(((r01*x452))+(((-1.0)*r21*x451))+((r11*x453)));
new_r02=(((r02*x452))+((r12*x453))+(((-1.0)*r22*x451)));
new_r10=((((-1.0)*r20*x454))+((r10*x460))+((r00*x457)));
new_r11=((((-1.0)*r21*x454))+((r01*x457))+((r11*x460)));
new_r12=((((-1.0)*r22*x454))+((r12*x460))+((r02*x457)));
new_r20=(((r10*x462))+(((-1.0)*r20*x461))+((r00*x463)));
new_r21=(((r11*x462))+(((-1.0)*r21*x461))+((r01*x463)));
new_r22=(((r12*x462))+(((-1.0)*r22*x461))+((r02*x463)));
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x464=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x465=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
evalcond[6]=x464;
evalcond[7]=x464;
evalcond[8]=x465;
evalcond[9]=x465;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x466=((1.0)*new_r01);
if( IKabs(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x466)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x466)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x466))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x466))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x466))), (((cj4*new_r00))+(((-1.0)*sj4*x466))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x467=IKsin(j6);
IkReal x468=IKcos(j6);
IkReal x469=((1.0)*x468);
IkReal x470=((-1.0)*x469);
IkReal x471=(cj4*x467);
IkReal x472=(((sj4*x467))+(((-1.0)*cj4*x469)));
IkReal x473=((1.0)*sj4);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x467);
evalcond[1]=(x470+((cj4*new_r00))+((new_r10*sj4)));
evalcond[2]=(x471+new_r01+((sj4*x468)));
evalcond[3]=(x472+new_r00);
evalcond[4]=(x472+new_r11);
evalcond[5]=(((cj4*new_r10))+(((-1.0)*new_r00*x473))+(((-1.0)*x467)));
evalcond[6]=(x470+(((-1.0)*new_r01*x473))+((cj4*new_r11)));
evalcond[7]=((((-1.0)*x468*x473))+(((-1.0)*x471))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x474=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x475=(cj4*new_r12);
IkReal x476=(new_r02*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
evalcond[6]=x474;
evalcond[7]=x474;
evalcond[8]=(x475+(((-1.0)*x476)));
evalcond[9]=(x476+(((-1.0)*x475)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x477=((1.0)*cj4);
if( IKabs(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x477)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x477))+((new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x477))))+IKsqr(((((-1.0)*new_r11*x477))+((new_r01*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r11*sj4))+(((-1.0)*new_r01*x477))), ((((-1.0)*new_r11*x477))+((new_r01*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x478=IKsin(j6);
IkReal x479=((1.0)*sj4);
IkReal x480=IKcos(j6);
IkReal x481=(cj4*x480);
IkReal x482=((((-1.0)*x479*x480))+((cj4*x478)));
evalcond[0]=(x478+((cj4*new_r01))+((new_r11*sj4)));
evalcond[1]=(x478+(((-1.0)*new_r00*x479))+((cj4*new_r10)));
evalcond[2]=((((-1.0)*new_r01*x479))+((cj4*new_r11))+x480);
evalcond[3]=((((-1.0)*x480))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(((sj4*x478))+new_r11+x481);
evalcond[5]=(new_r01+x482);
evalcond[6]=(new_r10+x482);
evalcond[7]=((((-1.0)*x481))+(((-1.0)*x478*x479))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x483=((1.0)*sj4);
IkReal x484=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x485=((1.0)+((cj4*new_r12))+(((-1.0)*new_r02*x483)));
IkReal x486=(((cj4*new_r10))+(((-1.0)*new_r00*x483)));
IkReal x487=(((cj4*new_r11))+(((-1.0)*new_r01*x483)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r12);
evalcond[3]=((((-1.0)*x483))+new_r02);
evalcond[4]=x484;
evalcond[5]=x484;
evalcond[6]=x485;
evalcond[7]=x486;
evalcond[8]=x487;
evalcond[9]=x486;
evalcond[10]=x487;
evalcond[11]=x485;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r20, new_r21);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x488=IKsin(j6);
IkReal x489=IKcos(j6);
IkReal x490=((1.0)*x489);
IkReal x491=((-1.0)*x490);
IkReal x492=((1.0)*new_r12);
evalcond[0]=((((-1.0)*x488))+new_r20);
evalcond[1]=(x491+new_r21);
evalcond[2]=(((new_r12*x489))+new_r00);
evalcond[3]=(((new_r02*x488))+new_r11);
evalcond[4]=((((-1.0)*x488*x492))+new_r01);
evalcond[5]=((((-1.0)*new_r02*x490))+new_r10);
evalcond[6]=(((new_r02*new_r11))+x488+(((-1.0)*new_r01*x492)));
evalcond[7]=((((-1.0)*new_r00*x492))+((new_r02*new_r10))+x491);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x493=((1.0)*cj4);
IkReal x494=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x495=(new_r02*sj4);
IkReal x496=(new_r00*sj4);
IkReal x497=(new_r01*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(new_r12+(((-1.0)*x493)));
evalcond[3]=(sj4+new_r02);
evalcond[4]=x494;
evalcond[5]=x494;
evalcond[6]=((-1.0)+((cj4*new_r12))+(((-1.0)*x495)));
evalcond[7]=(((cj4*new_r10))+(((-1.0)*x496)));
evalcond[8]=(((cj4*new_r11))+(((-1.0)*x497)));
evalcond[9]=((((-1.0)*new_r10*x493))+x496);
evalcond[10]=((((-1.0)*new_r11*x493))+x497);
evalcond[11]=((1.0)+(((-1.0)*new_r12*x493))+x495);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r20))))+IKsqr(((-1.0)*(((1.0)*new_r21))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r20))), ((-1.0)*(((1.0)*new_r21))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x498=IKsin(j6);
IkReal x499=IKcos(j6);
IkReal x500=((1.0)*x499);
IkReal x501=((1.0)*new_r02);
evalcond[0]=(x498+new_r20);
evalcond[1]=(x499+new_r21);
evalcond[2]=(((new_r12*x498))+new_r01);
evalcond[3]=(new_r10+((new_r02*x499)));
evalcond[4]=((((-1.0)*new_r12*x500))+new_r00);
evalcond[5]=((((-1.0)*x498*x501))+new_r11);
evalcond[6]=(((new_r01*new_r12))+(((-1.0)*new_r11*x501))+x498);
evalcond[7]=(((new_r00*new_r12))+(((-1.0)*x500))+(((-1.0)*new_r10*x501)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x502=((1.0)*cj5);
IkReal x503=((((-1.0)*x502))+new_r22);
IkReal x504=(sj5+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x503;
evalcond[2]=x503;
evalcond[3]=x504;
evalcond[4]=new_r02;
evalcond[5]=x504;
evalcond[6]=(((new_r22*sj5))+((cj5*new_r12)));
evalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x502)));
evalcond[8]=(((new_r11*sj5))+(((-1.0)*new_r21*x502)));
evalcond[9]=((1.0)+((new_r12*sj5))+(((-1.0)*new_r22*x502)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r01))))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r01))), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x505=IKsin(j6);
IkReal x506=IKcos(j6);
IkReal x507=((1.0)*x506);
IkReal x508=((-1.0)*x507);
IkReal x509=((1.0)*x505);
IkReal x510=((1.0)*new_r12);
evalcond[0]=(x505+new_r01);
evalcond[1]=(((new_r12*x505))+new_r20);
evalcond[2]=(((new_r12*x506))+new_r21);
evalcond[3]=(x508+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r22*x507)));
evalcond[5]=((((-1.0)*new_r22*x509))+new_r10);
evalcond[6]=(((new_r10*new_r22))+(((-1.0)*new_r20*x510))+(((-1.0)*x509)));
evalcond[7]=(((new_r11*new_r22))+x508+(((-1.0)*new_r21*x510)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x511=((1.0)*cj5);
IkReal x512=((((-1.0)*x511))+new_r22);
IkReal x513=((1.0)*sj5);
IkReal x514=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x512;
evalcond[2]=x512;
evalcond[3]=((((-1.0)*x513))+new_r12);
evalcond[4]=new_r02;
evalcond[5]=((((-1.0)*x514))+sj5);
evalcond[6]=(((new_r22*sj5))+(((-1.0)*new_r12*x511)));
evalcond[7]=((((-1.0)*new_r10*x513))+(((-1.0)*new_r20*x511)));
evalcond[8]=((((-1.0)*new_r11*x513))+(((-1.0)*new_r21*x511)));
evalcond[9]=((1.0)+(((-1.0)*sj5*x514))+(((-1.0)*new_r22*x511)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*(((1.0)*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r01, ((-1.0)*(((1.0)*new_r00))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x515=IKsin(j6);
IkReal x516=IKcos(j6);
IkReal x517=((1.0)*x515);
IkReal x518=((1.0)*x516);
IkReal x519=((-1.0)*x518);
IkReal x520=((1.0)*new_r10);
IkReal x521=((1.0)*new_r22);
evalcond[0]=((((-1.0)*(1.0)*new_r01))+x515);
evalcond[1]=(((new_r22*x516))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x517))+new_r20);
evalcond[3]=((((-1.0)*new_r12*x518))+new_r21);
evalcond[4]=((((-1.0)*(1.0)*new_r00))+x519);
evalcond[5]=((((-1.0)*x515*x521))+(((-1.0)*x520)));
evalcond[6]=((((-1.0)*new_r22*x520))+(((-1.0)*x517))+((new_r12*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x521))+((new_r12*new_r21))+x519);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x522=((1.0)*cj5);
IkReal x523=((((-1.0)*x522))+new_r22);
IkReal x524=((1.0)*sj5);
IkReal x525=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x523;
evalcond[2]=x523;
evalcond[3]=new_r12;
evalcond[4]=((((-1.0)*x524))+new_r02);
evalcond[5]=((((-1.0)*x525))+sj5);
evalcond[6]=(((new_r22*sj5))+(((-1.0)*new_r02*x522)));
evalcond[7]=((((-1.0)*new_r20*x522))+(((-1.0)*new_r00*x524)));
evalcond[8]=((((-1.0)*new_r01*x524))+(((-1.0)*new_r21*x522)));
evalcond[9]=((1.0)+(((-1.0)*sj5*x525))+(((-1.0)*new_r22*x522)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r11))))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r11))), new_r10);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x526=IKsin(j6);
IkReal x527=IKcos(j6);
IkReal x528=((1.0)*x527);
IkReal x529=((-1.0)*x528);
IkReal x530=((1.0)*x526);
IkReal x531=((1.0)*new_r22);
evalcond[0]=(new_r11+x526);
evalcond[1]=(new_r10+x529);
evalcond[2]=(((new_r22*x527))+new_r01);
evalcond[3]=(((new_r22*x526))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x530))+new_r20);
evalcond[5]=((((-1.0)*new_r02*x528))+new_r21);
evalcond[6]=(((new_r02*new_r20))+(((-1.0)*x530))+(((-1.0)*new_r00*x531)));
evalcond[7]=(((new_r02*new_r21))+(((-1.0)*new_r01*x531))+x529);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x532=((1.0)*cj5);
IkReal x533=((((-1.0)*x532))+new_r22);
IkReal x534=(sj5+new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x533;
evalcond[2]=x533;
evalcond[3]=new_r12;
evalcond[4]=x534;
evalcond[5]=x534;
evalcond[6]=(((new_r22*sj5))+((cj5*new_r02)));
evalcond[7]=((((-1.0)*new_r20*x532))+((new_r00*sj5)));
evalcond[8]=((((-1.0)*new_r21*x532))+((new_r01*sj5)));
evalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x532)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x535=((1.0)*cj2);
IkReal x536=(cj1*sj2);
IkReal x537=(sj1*sj2);
IkReal x538=((1.0)*sj2*sj3);
IkReal x539=(cj3*sj1);
IkReal x540=(cj1*sj3);
IkReal x541=(x539+(((-1.0)*x535*x540)));
IkReal x542=((1.0)*cj1*cj3);
IkReal x543=(sj1*sj3);
IkReal x544=x256;
IkReal x545=((1.0)*cj3*sj2);
IkReal x546=(x540+(((-1.0)*x535*x539)));
IkReal x547=x259;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
new_r00=(((r00*x536))+((r10*x537))+(((-1.0)*r20*x535)));
new_r01=(((r11*x537))+(((-1.0)*r21*x535))+((r01*x536)));
new_r02=((((-1.0)*r22*x535))+((r12*x537))+((r02*x536)));
new_r10=((((-1.0)*r20*x538))+((r00*x541))+((r10*x544)));
new_r11=(((r11*x544))+(((-1.0)*r21*x538))+((r01*x541)));
new_r12=(((r12*x544))+(((-1.0)*r22*x538))+((r02*x541)));
new_r20=((((-1.0)*r20*x545))+((r00*x547))+((r10*x546)));
new_r21=(((r01*x547))+(((-1.0)*r21*x545))+((r11*x546)));
new_r22=(((r02*x547))+((r12*x546))+(((-1.0)*r22*x545)));
IkReal x548=(cj3*sj2);
IkReal x549=(sj1*sj3);
IkReal x550=((1.0)*cj1*sj3);
IkReal x551=(cj1*cj2*cj3);
IkReal x552=(cj2*cj3*sj1);
j6eval[0]=((IKabs(((((-1.0)*r11*x550))+((r01*x549))+((r01*x551))+((r11*x552))+((r21*x548)))))+(IKabs((((r00*x551))+((r20*x548))+((r00*x549))+(((-1.0)*r10*x550))+((r10*x552))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x553=IKPowWithIntegerCheck(new_r02,-1);
if(!x553.valid){
continue;
}
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r21*(x553.value))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*(((1.0)*new_r21*(x553.value)))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*(((1.0)*new_r21*(x553.value)))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x554=IKsin(j6);
IkReal x555=IKcos(j6);
IkReal x556=((1.0)*x555);
IkReal x557=((1.0)*x554);
IkReal x558=((-1.0)*x556);
IkReal x559=((1.0)*new_r02);
evalcond[0]=(((new_r02*x554))+new_r20);
evalcond[1]=(((new_r02*x555))+new_r21);
evalcond[2]=(x554+(((-1.0)*(1.0)*new_r11)));
evalcond[3]=(new_r01+(((-1.0)*new_r22*x556)));
evalcond[4]=((((-1.0)*new_r22*x557))+new_r00);
evalcond[5]=((((-1.0)*(1.0)*new_r10))+x558);
evalcond[6]=((((-1.0)*new_r20*x559))+(((-1.0)*x557))+((new_r00*new_r22)));
evalcond[7]=(((new_r01*new_r22))+x558+(((-1.0)*new_r21*x559)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x560 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r20)))),((-1.0)*(((1.0)*new_r21))),IKFAST_ATAN2_MAGTHRESH);
if(!x560.valid){
continue;
}
CheckValue<IkReal> x561=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x561.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x560.value)+(((1.5707963267949)*(x561.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x562=IKsin(j6);
IkReal x563=IKcos(j6);
IkReal x564=((1.0)*x563);
IkReal x565=((1.0)*x562);
IkReal x566=((-1.0)*x564);
IkReal x567=((1.0)*new_r02);
evalcond[0]=(((new_r02*x562))+new_r20);
evalcond[1]=(((new_r02*x563))+new_r21);
evalcond[2]=((((-1.0)*(1.0)*new_r11))+x562);
evalcond[3]=(new_r01+(((-1.0)*new_r22*x564)));
evalcond[4]=(new_r00+(((-1.0)*new_r22*x565)));
evalcond[5]=((((-1.0)*(1.0)*new_r10))+x566);
evalcond[6]=((((-1.0)*new_r20*x567))+(((-1.0)*x565))+((new_r00*new_r22)));
evalcond[7]=(((new_r01*new_r22))+(((-1.0)*new_r21*x567))+x566);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x569=IKPowWithIntegerCheck(sj5,-1);
if(!x569.valid){
continue;
}
IkReal x568=x569.value;
CheckValue<IkReal> x570=IKPowWithIntegerCheck(cj5,-1);
if(!x570.valid){
continue;
}
CheckValue<IkReal> x571=IKPowWithIntegerCheck(sj4,-1);
if(!x571.valid){
continue;
}
if( IKabs((new_r20*x568)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x568*(x570.value)*(x571.value)*(((((-1.0)*(1.0)*cj4*new_r20))+(((-1.0)*(1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x568))+IKsqr((x568*(x570.value)*(x571.value)*(((((-1.0)*(1.0)*cj4*new_r20))+(((-1.0)*(1.0)*new_r01*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((new_r20*x568), (x568*(x570.value)*(x571.value)*(((((-1.0)*(1.0)*cj4*new_r20))+(((-1.0)*(1.0)*new_r01*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x572=IKsin(j6);
IkReal x573=((1.0)*x572);
IkReal x574=IKcos(j6);
IkReal x575=((1.0)*x574);
IkReal x576=((-1.0)*x575);
IkReal x577=(cj4*x572);
IkReal x578=(cj4*x575);
IkReal x579=(sj4*x572);
IkReal x580=(cj4*new_r10);
IkReal x581=((1.0)*sj4);
IkReal x582=(new_r00*x581);
IkReal x583=(cj4*new_r11);
IkReal x584=(new_r01*x581);
evalcond[0]=((((-1.0)*sj5*x573))+new_r20);
evalcond[1]=((((-1.0)*sj5*x575))+new_r21);
evalcond[2]=(x572+((cj4*new_r01))+((new_r11*sj4)));
evalcond[3]=(x576+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(((cj5*sj4*x574))+x577+new_r01);
evalcond[5]=(((cj5*x579))+(((-1.0)*x578))+new_r00);
evalcond[6]=((((-1.0)*cj5*x578))+x579+new_r11);
evalcond[7]=((((-1.0)*x582))+x580+(((-1.0)*cj5*x573)));
evalcond[8]=((((-1.0)*x584))+x583+(((-1.0)*cj5*x575)));
evalcond[9]=((((-1.0)*x574*x581))+(((-1.0)*cj5*x577))+new_r10);
evalcond[10]=(((new_r20*sj5))+(((-1.0)*x573))+((cj5*x580))+(((-1.0)*cj5*x582)));
evalcond[11]=(x576+((cj5*x583))+(((-1.0)*cj5*x584))+((new_r21*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x586=IKPowWithIntegerCheck(sj5,-1);
if(!x586.valid){
continue;
}
IkReal x585=x586.value;
CheckValue<IkReal> x587=IKPowWithIntegerCheck(cj4,-1);
if(!x587.valid){
continue;
}
if( IKabs((new_r20*x585)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x585*(x587.value)*((((cj5*new_r20*sj4))+((new_r00*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x585))+IKsqr((x585*(x587.value)*((((cj5*new_r20*sj4))+((new_r00*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((new_r20*x585), (x585*(x587.value)*((((cj5*new_r20*sj4))+((new_r00*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x588=IKsin(j6);
IkReal x589=((1.0)*x588);
IkReal x590=IKcos(j6);
IkReal x591=((1.0)*x590);
IkReal x592=((-1.0)*x591);
IkReal x593=(cj4*x588);
IkReal x594=(cj4*x591);
IkReal x595=(sj4*x588);
IkReal x596=(cj4*new_r10);
IkReal x597=((1.0)*sj4);
IkReal x598=(new_r00*x597);
IkReal x599=(cj4*new_r11);
IkReal x600=(new_r01*x597);
evalcond[0]=((((-1.0)*sj5*x589))+new_r20);
evalcond[1]=((((-1.0)*sj5*x591))+new_r21);
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x588);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+x592);
evalcond[4]=(new_r01+x593+((cj5*sj4*x590)));
evalcond[5]=((((-1.0)*x594))+((cj5*x595))+new_r00);
evalcond[6]=(new_r11+x595+(((-1.0)*cj5*x594)));
evalcond[7]=((((-1.0)*x598))+(((-1.0)*cj5*x589))+x596);
evalcond[8]=((((-1.0)*cj5*x591))+(((-1.0)*x600))+x599);
evalcond[9]=((((-1.0)*x590*x597))+new_r10+(((-1.0)*cj5*x593)));
evalcond[10]=(((new_r20*sj5))+(((-1.0)*x589))+((cj5*x596))+(((-1.0)*cj5*x598)));
evalcond[11]=((((-1.0)*cj5*x600))+((new_r21*sj5))+((cj5*x599))+x592);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x601 = IKatan2WithCheck(IkReal(new_r20),new_r21,IKFAST_ATAN2_MAGTHRESH);
if(!x601.valid){
continue;
}
CheckValue<IkReal> x602=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x602.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x601.value)+(((1.5707963267949)*(x602.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x603=IKsin(j6);
IkReal x604=((1.0)*x603);
IkReal x605=IKcos(j6);
IkReal x606=((1.0)*x605);
IkReal x607=((-1.0)*x606);
IkReal x608=(cj4*x603);
IkReal x609=(cj4*x606);
IkReal x610=(sj4*x603);
IkReal x611=(cj4*new_r10);
IkReal x612=((1.0)*sj4);
IkReal x613=(new_r00*x612);
IkReal x614=(cj4*new_r11);
IkReal x615=(new_r01*x612);
evalcond[0]=((((-1.0)*sj5*x604))+new_r20);
evalcond[1]=((((-1.0)*sj5*x606))+new_r21);
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x603);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+x607);
evalcond[4]=(((cj5*sj4*x605))+new_r01+x608);
evalcond[5]=((((-1.0)*x609))+new_r00+((cj5*x610)));
evalcond[6]=(x610+(((-1.0)*cj5*x609))+new_r11);
evalcond[7]=(x611+(((-1.0)*x613))+(((-1.0)*cj5*x604)));
evalcond[8]=(x614+(((-1.0)*x615))+(((-1.0)*cj5*x606)));
evalcond[9]=((((-1.0)*cj5*x608))+(((-1.0)*x605*x612))+new_r10);
evalcond[10]=(((new_r20*sj5))+(((-1.0)*cj5*x613))+(((-1.0)*x604))+((cj5*x611)));
evalcond[11]=(((new_r21*sj5))+((cj5*x614))+(((-1.0)*cj5*x615))+x607);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x616=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x616.valid){
continue;
}
CheckValue<IkReal> x617 = IKatan2WithCheck(IkReal(new_r02),((-1.0)*(((1.0)*new_r12))),IKFAST_ATAN2_MAGTHRESH);
if(!x617.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x616.value)))+(x617.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x618=IKcos(j4);
IkReal x619=(sj5*x618);
IkReal x620=IKsin(j4);
IkReal x621=((1.0)*x620);
IkReal x622=(sj5*x621);
IkReal x623=(new_r12*x618);
IkReal x624=(new_r02*x621);
IkReal x625=((1.0)*cj5);
evalcond[0]=(x619+new_r12);
evalcond[1]=((((-1.0)*x622))+new_r02);
evalcond[2]=(((new_r12*x620))+((new_r02*x618)));
evalcond[3]=((((-1.0)*x624))+x623+sj5);
evalcond[4]=(((new_r22*sj5))+(((-1.0)*new_r02*x620*x625))+((cj5*x623)));
evalcond[5]=((((-1.0)*new_r20*x625))+(((-1.0)*new_r00*x622))+((new_r10*x619)));
evalcond[6]=(((new_r11*x619))+(((-1.0)*new_r01*x622))+(((-1.0)*new_r21*x625)));
evalcond[7]=((1.0)+((sj5*x623))+(((-1.0)*sj5*x624))+(((-1.0)*new_r22*x625)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
IkReal x626=((1.0)*cj2);
IkReal x627=(cj1*sj2);
IkReal x628=(sj1*sj2);
IkReal x629=((1.0)*sj2*sj3);
IkReal x630=(cj3*sj1);
IkReal x631=(cj1*sj3);
IkReal x632=(x630+(((-1.0)*x626*x631)));
IkReal x633=((1.0)*cj1*cj3);
IkReal x634=(sj1*sj3);
IkReal x635=x256;
IkReal x636=((1.0)*cj3*sj2);
IkReal x637=(x631+(((-1.0)*x626*x630)));
IkReal x638=x259;
new_r00=(((r00*x627))+(((-1.0)*r20*x626))+((r10*x628)));
new_r01=(((r11*x628))+((r01*x627))+(((-1.0)*r21*x626)));
new_r02=(((r12*x628))+(((-1.0)*r22*x626))+((r02*x627)));
new_r10=(((r00*x632))+((r10*x635))+(((-1.0)*r20*x629)));
new_r11=(((r01*x632))+(((-1.0)*r21*x629))+((r11*x635)));
new_r12=(((r12*x635))+((r02*x632))+(((-1.0)*r22*x629)));
new_r20=(((r00*x638))+(((-1.0)*r20*x636))+((r10*x637)));
new_r21=(((r11*x637))+((r01*x638))+(((-1.0)*r21*x636)));
new_r22=((((-1.0)*r22*x636))+((r02*x638))+((r12*x637)));
IkReal x639=(cj1*sj3);
IkReal x640=((1.0)*cj3*sj2);
IkReal x641=((1.0)*sj1*sj3);
IkReal x642=((1.0)*cj1*cj2*cj3);
IkReal x643=((1.0)*cj2*cj3*sj1);
j6eval[0]=sj5;
j6eval[1]=((IKabs(((((-1.0)*r20*x640))+(((-1.0)*r00*x642))+(((-1.0)*r00*x641))+((r10*x639))+(((-1.0)*r10*x643)))))+(IKabs((((r11*x639))+(((-1.0)*r11*x643))+(((-1.0)*r01*x642))+(((-1.0)*r01*x641))+(((-1.0)*r21*x640))))));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
IkReal x644=((1.0)*cj2);
IkReal x645=(cj1*sj2);
IkReal x646=(sj1*sj2);
IkReal x647=((1.0)*sj2*sj3);
IkReal x648=(cj3*sj1);
IkReal x649=(cj1*sj3);
IkReal x650=((((-1.0)*x644*x649))+x648);
IkReal x651=((1.0)*cj1*cj3);
IkReal x652=(sj1*sj3);
IkReal x653=x256;
IkReal x654=((1.0)*cj3*sj2);
IkReal x655=((((-1.0)*x644*x648))+x649);
IkReal x656=x259;
new_r00=(((r00*x645))+(((-1.0)*r20*x644))+((r10*x646)));
new_r01=((((-1.0)*r21*x644))+((r01*x645))+((r11*x646)));
new_r02=(((r12*x646))+(((-1.0)*r22*x644))+((r02*x645)));
new_r10=(((r10*x653))+(((-1.0)*r20*x647))+((r00*x650)));
new_r11=(((r01*x650))+(((-1.0)*r21*x647))+((r11*x653)));
new_r12=((((-1.0)*r22*x647))+((r02*x650))+((r12*x653)));
new_r20=(((r10*x655))+(((-1.0)*r20*x654))+((r00*x656)));
new_r21=((((-1.0)*r21*x654))+((r01*x656))+((r11*x655)));
new_r22=((((-1.0)*r22*x654))+((r12*x655))+((r02*x656)));
j6eval[0]=sj5;
j6eval[1]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
IkReal x657=((1.0)*cj2);
IkReal x658=(cj1*sj2);
IkReal x659=(sj1*sj2);
IkReal x660=((1.0)*sj2*sj3);
IkReal x661=(cj3*sj1);
IkReal x662=(cj1*sj3);
IkReal x663=((((-1.0)*x657*x662))+x661);
IkReal x664=((1.0)*cj1*cj3);
IkReal x665=(sj1*sj3);
IkReal x666=x256;
IkReal x667=((1.0)*cj3*sj2);
IkReal x668=((((-1.0)*x657*x661))+x662);
IkReal x669=x259;
new_r00=((((-1.0)*r20*x657))+((r10*x659))+((r00*x658)));
new_r01=(((r01*x658))+(((-1.0)*r21*x657))+((r11*x659)));
new_r02=((((-1.0)*r22*x657))+((r12*x659))+((r02*x658)));
new_r10=(((r00*x663))+(((-1.0)*r20*x660))+((r10*x666)));
new_r11=((((-1.0)*r21*x660))+((r01*x663))+((r11*x666)));
new_r12=((((-1.0)*r22*x660))+((r02*x663))+((r12*x666)));
new_r20=(((r10*x668))+((r00*x669))+(((-1.0)*r20*x667)));
new_r21=(((r01*x669))+((r11*x668))+(((-1.0)*r21*x667)));
new_r22=(((r12*x668))+((r02*x669))+(((-1.0)*r22*x667)));
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x670=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x671=((((-1.0)*(1.0)*new_r02*sj4))+((cj4*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
evalcond[6]=x670;
evalcond[7]=x670;
evalcond[8]=x671;
evalcond[9]=x671;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x672=((1.0)*new_r01);
if( IKabs(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x672)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x672))+((cj4*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x672))))+IKsqr(((((-1.0)*sj4*x672))+((cj4*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj4*x672))), ((((-1.0)*sj4*x672))+((cj4*new_r00))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x673=IKsin(j6);
IkReal x674=IKcos(j6);
IkReal x675=((1.0)*x674);
IkReal x676=((-1.0)*x675);
IkReal x677=(cj4*x673);
IkReal x678=((((-1.0)*cj4*x675))+((sj4*x673)));
IkReal x679=((1.0)*sj4);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x673);
evalcond[1]=(((cj4*new_r00))+((new_r10*sj4))+x676);
evalcond[2]=(((sj4*x674))+new_r01+x677);
evalcond[3]=(new_r00+x678);
evalcond[4]=(new_r11+x678);
evalcond[5]=((((-1.0)*new_r00*x679))+((cj4*new_r10))+(((-1.0)*x673)));
evalcond[6]=((((-1.0)*new_r01*x679))+((cj4*new_r11))+x676);
evalcond[7]=((((-1.0)*x677))+(((-1.0)*x674*x679))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x680=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x681=(cj4*new_r12);
IkReal x682=(new_r02*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
evalcond[6]=x680;
evalcond[7]=x680;
evalcond[8]=((((-1.0)*x682))+x681);
evalcond[9]=((((-1.0)*x681))+x682);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x683=((1.0)*cj4);
if( IKabs(((((-1.0)*new_r01*x683))+(((-1.0)*(1.0)*new_r11*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r11*x683))+((new_r01*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r01*x683))+(((-1.0)*(1.0)*new_r11*sj4))))+IKsqr(((((-1.0)*new_r11*x683))+((new_r01*sj4))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r01*x683))+(((-1.0)*(1.0)*new_r11*sj4))), ((((-1.0)*new_r11*x683))+((new_r01*sj4))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x684=IKsin(j6);
IkReal x685=((1.0)*sj4);
IkReal x686=IKcos(j6);
IkReal x687=(cj4*x686);
IkReal x688=((((-1.0)*x685*x686))+((cj4*x684)));
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x684);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x685))+x684);
evalcond[2]=((((-1.0)*new_r01*x685))+((cj4*new_r11))+x686);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x686)));
evalcond[4]=(((sj4*x684))+new_r11+x687);
evalcond[5]=(new_r01+x688);
evalcond[6]=(new_r10+x688);
evalcond[7]=((((-1.0)*x687))+(((-1.0)*x684*x685))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x689=((1.0)*sj4);
IkReal x690=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x691=((1.0)+((cj4*new_r12))+(((-1.0)*new_r02*x689)));
IkReal x692=(((cj4*new_r10))+(((-1.0)*new_r00*x689)));
IkReal x693=(((cj4*new_r11))+(((-1.0)*new_r01*x689)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj4+new_r12);
evalcond[3]=((((-1.0)*x689))+new_r02);
evalcond[4]=x690;
evalcond[5]=x690;
evalcond[6]=x691;
evalcond[7]=x692;
evalcond[8]=x693;
evalcond[9]=x692;
evalcond[10]=x693;
evalcond[11]=x691;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r20, new_r21);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x694=IKsin(j6);
IkReal x695=IKcos(j6);
IkReal x696=((1.0)*x695);
IkReal x697=((-1.0)*x696);
IkReal x698=((1.0)*new_r12);
evalcond[0]=((((-1.0)*x694))+new_r20);
evalcond[1]=(x697+new_r21);
evalcond[2]=(((new_r12*x695))+new_r00);
evalcond[3]=(new_r11+((new_r02*x694)));
evalcond[4]=((((-1.0)*x694*x698))+new_r01);
evalcond[5]=((((-1.0)*new_r02*x696))+new_r10);
evalcond[6]=(((new_r02*new_r11))+(((-1.0)*new_r01*x698))+x694);
evalcond[7]=((((-1.0)*new_r00*x698))+x697+((new_r02*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x699=((1.0)*cj4);
IkReal x700=(((cj4*new_r02))+((new_r12*sj4)));
IkReal x701=(new_r02*sj4);
IkReal x702=(new_r00*sj4);
IkReal x703=(new_r01*sj4);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x699))+new_r12);
evalcond[3]=(sj4+new_r02);
evalcond[4]=x700;
evalcond[5]=x700;
evalcond[6]=((-1.0)+((cj4*new_r12))+(((-1.0)*x701)));
evalcond[7]=(((cj4*new_r10))+(((-1.0)*x702)));
evalcond[8]=(((cj4*new_r11))+(((-1.0)*x703)));
evalcond[9]=((((-1.0)*new_r10*x699))+x702);
evalcond[10]=((((-1.0)*new_r11*x699))+x703);
evalcond[11]=((1.0)+(((-1.0)*new_r12*x699))+x701);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r20))))+IKsqr(((-1.0)*(((1.0)*new_r21))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r20))), ((-1.0)*(((1.0)*new_r21))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x704=IKsin(j6);
IkReal x705=IKcos(j6);
IkReal x706=((1.0)*x705);
IkReal x707=((1.0)*new_r02);
evalcond[0]=(x704+new_r20);
evalcond[1]=(x705+new_r21);
evalcond[2]=(new_r01+((new_r12*x704)));
evalcond[3]=(new_r10+((new_r02*x705)));
evalcond[4]=((((-1.0)*new_r12*x706))+new_r00);
evalcond[5]=((((-1.0)*x704*x707))+new_r11);
evalcond[6]=(((new_r01*new_r12))+x704+(((-1.0)*new_r11*x707)));
evalcond[7]=(((new_r00*new_r12))+(((-1.0)*x706))+(((-1.0)*new_r10*x707)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x708=((1.0)*cj5);
IkReal x709=((((-1.0)*x708))+new_r22);
IkReal x710=(sj5+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=x709;
evalcond[2]=x709;
evalcond[3]=x710;
evalcond[4]=new_r02;
evalcond[5]=x710;
evalcond[6]=(((new_r22*sj5))+((cj5*new_r12)));
evalcond[7]=(((new_r10*sj5))+(((-1.0)*new_r20*x708)));
evalcond[8]=((((-1.0)*new_r21*x708))+((new_r11*sj5)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x708))+((new_r12*sj5)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r01))))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r01))), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x711=IKsin(j6);
IkReal x712=IKcos(j6);
IkReal x713=((1.0)*x712);
IkReal x714=((-1.0)*x713);
IkReal x715=((1.0)*x711);
IkReal x716=((1.0)*new_r12);
evalcond[0]=(x711+new_r01);
evalcond[1]=(((new_r12*x711))+new_r20);
evalcond[2]=(((new_r12*x712))+new_r21);
evalcond[3]=(x714+new_r00);
evalcond[4]=((((-1.0)*new_r22*x713))+new_r11);
evalcond[5]=((((-1.0)*new_r22*x715))+new_r10);
evalcond[6]=(((new_r10*new_r22))+(((-1.0)*x715))+(((-1.0)*new_r20*x716)));
evalcond[7]=(((new_r11*new_r22))+x714+(((-1.0)*new_r21*x716)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x717=((1.0)*cj5);
IkReal x718=((((-1.0)*x717))+new_r22);
IkReal x719=((1.0)*sj5);
IkReal x720=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=x718;
evalcond[2]=x718;
evalcond[3]=(new_r12+(((-1.0)*x719)));
evalcond[4]=new_r02;
evalcond[5]=(sj5+(((-1.0)*x720)));
evalcond[6]=(((new_r22*sj5))+(((-1.0)*new_r12*x717)));
evalcond[7]=((((-1.0)*new_r20*x717))+(((-1.0)*new_r10*x719)));
evalcond[8]=((((-1.0)*new_r11*x719))+(((-1.0)*new_r21*x717)));
evalcond[9]=((1.0)+(((-1.0)*sj5*x720))+(((-1.0)*new_r22*x717)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*(((1.0)*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r01, ((-1.0)*(((1.0)*new_r00))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x721=IKsin(j6);
IkReal x722=IKcos(j6);
IkReal x723=((1.0)*x721);
IkReal x724=((1.0)*x722);
IkReal x725=((-1.0)*x724);
IkReal x726=((1.0)*new_r10);
IkReal x727=((1.0)*new_r22);
evalcond[0]=((((-1.0)*(1.0)*new_r01))+x721);
evalcond[1]=(((new_r22*x722))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x723))+new_r20);
evalcond[3]=((((-1.0)*new_r12*x724))+new_r21);
evalcond[4]=((((-1.0)*(1.0)*new_r00))+x725);
evalcond[5]=((((-1.0)*x726))+(((-1.0)*x721*x727)));
evalcond[6]=((((-1.0)*x723))+((new_r12*new_r20))+(((-1.0)*new_r22*x726)));
evalcond[7]=((((-1.0)*new_r11*x727))+((new_r12*new_r21))+x725);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x728=((1.0)*cj5);
IkReal x729=((((-1.0)*x728))+new_r22);
IkReal x730=((1.0)*sj5);
IkReal x731=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x729;
evalcond[2]=x729;
evalcond[3]=new_r12;
evalcond[4]=(new_r02+(((-1.0)*x730)));
evalcond[5]=(sj5+(((-1.0)*x731)));
evalcond[6]=(((new_r22*sj5))+(((-1.0)*new_r02*x728)));
evalcond[7]=((((-1.0)*new_r20*x728))+(((-1.0)*new_r00*x730)));
evalcond[8]=((((-1.0)*new_r21*x728))+(((-1.0)*new_r01*x730)));
evalcond[9]=((1.0)+(((-1.0)*sj5*x731))+(((-1.0)*new_r22*x728)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r11)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r11))))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*(((1.0)*new_r11))), new_r10);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x732=IKsin(j6);
IkReal x733=IKcos(j6);
IkReal x734=((1.0)*x733);
IkReal x735=((-1.0)*x734);
IkReal x736=((1.0)*x732);
IkReal x737=((1.0)*new_r22);
evalcond[0]=(x732+new_r11);
evalcond[1]=(x735+new_r10);
evalcond[2]=(((new_r22*x733))+new_r01);
evalcond[3]=(((new_r22*x732))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x736))+new_r20);
evalcond[5]=((((-1.0)*new_r02*x734))+new_r21);
evalcond[6]=(((new_r02*new_r20))+(((-1.0)*new_r00*x737))+(((-1.0)*x736)));
evalcond[7]=(((new_r02*new_r21))+(((-1.0)*new_r01*x737))+x735);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x738=((1.0)*cj5);
IkReal x739=((((-1.0)*x738))+new_r22);
IkReal x740=(sj5+new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=x739;
evalcond[2]=x739;
evalcond[3]=new_r12;
evalcond[4]=x740;
evalcond[5]=x740;
evalcond[6]=(((new_r22*sj5))+((cj5*new_r02)));
evalcond[7]=((((-1.0)*new_r20*x738))+((new_r00*sj5)));
evalcond[8]=(((new_r01*sj5))+(((-1.0)*new_r21*x738)));
evalcond[9]=((1.0)+((new_r02*sj5))+(((-1.0)*new_r22*x738)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x741=((1.0)*cj2);
IkReal x742=(cj1*sj2);
IkReal x743=(sj1*sj2);
IkReal x744=((1.0)*sj2*sj3);
IkReal x745=(cj3*sj1);
IkReal x746=(cj1*sj3);
IkReal x747=((((-1.0)*x741*x746))+x745);
IkReal x748=((1.0)*cj1*cj3);
IkReal x749=(sj1*sj3);
IkReal x750=x256;
IkReal x751=((1.0)*cj3*sj2);
IkReal x752=((((-1.0)*x741*x745))+x746);
IkReal x753=x259;
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
new_r00=(((r00*x742))+(((-1.0)*r20*x741))+((r10*x743)));
new_r01=(((r11*x743))+((r01*x742))+(((-1.0)*r21*x741)));
new_r02=(((r02*x742))+((r12*x743))+(((-1.0)*r22*x741)));
new_r10=(((r00*x747))+(((-1.0)*r20*x744))+((r10*x750)));
new_r11=(((r11*x750))+(((-1.0)*r21*x744))+((r01*x747)));
new_r12=(((r02*x747))+((r12*x750))+(((-1.0)*r22*x744)));
new_r20=((((-1.0)*r20*x751))+((r00*x753))+((r10*x752)));
new_r21=(((r01*x753))+((r11*x752))+(((-1.0)*r21*x751)));
new_r22=(((r02*x753))+((r12*x752))+(((-1.0)*r22*x751)));
IkReal x754=(cj3*sj2);
IkReal x755=(sj1*sj3);
IkReal x756=((1.0)*cj1*sj3);
IkReal x757=(cj1*cj2*cj3);
IkReal x758=(cj2*cj3*sj1);
j6eval[0]=((IKabs(((((-1.0)*r11*x756))+((r01*x755))+((r21*x754))+((r01*x757))+((r11*x758)))))+(IKabs((((r10*x758))+((r20*x754))+((r00*x757))+(((-1.0)*r10*x756))+((r00*x755))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x759=IKPowWithIntegerCheck(new_r02,-1);
if(!x759.valid){
continue;
}
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r21*(x759.value))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*(((1.0)*new_r21*(x759.value)))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*(((1.0)*new_r21*(x759.value)))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x760=IKsin(j6);
IkReal x761=IKcos(j6);
IkReal x762=((1.0)*x761);
IkReal x763=((1.0)*x760);
IkReal x764=((-1.0)*x762);
IkReal x765=((1.0)*new_r02);
evalcond[0]=(((new_r02*x760))+new_r20);
evalcond[1]=(((new_r02*x761))+new_r21);
evalcond[2]=(x760+(((-1.0)*(1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r22*x762))+new_r01);
evalcond[4]=(new_r00+(((-1.0)*new_r22*x763)));
evalcond[5]=((((-1.0)*(1.0)*new_r10))+x764);
evalcond[6]=(((new_r00*new_r22))+(((-1.0)*x763))+(((-1.0)*new_r20*x765)));
evalcond[7]=(((new_r01*new_r22))+x764+(((-1.0)*new_r21*x765)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x766 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r20)))),((-1.0)*(((1.0)*new_r21))),IKFAST_ATAN2_MAGTHRESH);
if(!x766.valid){
continue;
}
CheckValue<IkReal> x767=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x767.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x766.value)+(((1.5707963267949)*(x767.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x768=IKsin(j6);
IkReal x769=IKcos(j6);
IkReal x770=((1.0)*x769);
IkReal x771=((1.0)*x768);
IkReal x772=((-1.0)*x770);
IkReal x773=((1.0)*new_r02);
evalcond[0]=(((new_r02*x768))+new_r20);
evalcond[1]=(((new_r02*x769))+new_r21);
evalcond[2]=(x768+(((-1.0)*(1.0)*new_r11)));
evalcond[3]=((((-1.0)*new_r22*x770))+new_r01);
evalcond[4]=((((-1.0)*new_r22*x771))+new_r00);
evalcond[5]=((((-1.0)*(1.0)*new_r10))+x772);
evalcond[6]=((((-1.0)*new_r20*x773))+(((-1.0)*x771))+((new_r00*new_r22)));
evalcond[7]=((((-1.0)*new_r21*x773))+((new_r01*new_r22))+x772);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x775=IKPowWithIntegerCheck(sj5,-1);
if(!x775.valid){
continue;
}
IkReal x774=x775.value;
CheckValue<IkReal> x776=IKPowWithIntegerCheck(cj5,-1);
if(!x776.valid){
continue;
}
CheckValue<IkReal> x777=IKPowWithIntegerCheck(sj4,-1);
if(!x777.valid){
continue;
}
if( IKabs((new_r20*x774)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x774*(x776.value)*(x777.value)*(((((-1.0)*(1.0)*cj4*new_r20))+(((-1.0)*(1.0)*new_r01*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x774))+IKsqr((x774*(x776.value)*(x777.value)*(((((-1.0)*(1.0)*cj4*new_r20))+(((-1.0)*(1.0)*new_r01*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((new_r20*x774), (x774*(x776.value)*(x777.value)*(((((-1.0)*(1.0)*cj4*new_r20))+(((-1.0)*(1.0)*new_r01*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x778=IKsin(j6);
IkReal x779=((1.0)*x778);
IkReal x780=IKcos(j6);
IkReal x781=((1.0)*x780);
IkReal x782=((-1.0)*x781);
IkReal x783=(cj4*x778);
IkReal x784=(cj4*x781);
IkReal x785=(sj4*x778);
IkReal x786=(cj4*new_r10);
IkReal x787=((1.0)*sj4);
IkReal x788=(new_r00*x787);
IkReal x789=(cj4*new_r11);
IkReal x790=(new_r01*x787);
evalcond[0]=((((-1.0)*sj5*x779))+new_r20);
evalcond[1]=((((-1.0)*sj5*x781))+new_r21);
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x778);
evalcond[3]=(x782+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(x783+((cj5*sj4*x780))+new_r01);
evalcond[5]=(((cj5*x785))+(((-1.0)*x784))+new_r00);
evalcond[6]=((((-1.0)*cj5*x784))+x785+new_r11);
evalcond[7]=(x786+(((-1.0)*cj5*x779))+(((-1.0)*x788)));
evalcond[8]=(x789+(((-1.0)*cj5*x781))+(((-1.0)*x790)));
evalcond[9]=((((-1.0)*cj5*x783))+(((-1.0)*x780*x787))+new_r10);
evalcond[10]=((((-1.0)*x779))+(((-1.0)*cj5*x788))+((new_r20*sj5))+((cj5*x786)));
evalcond[11]=(x782+((cj5*x789))+(((-1.0)*cj5*x790))+((new_r21*sj5)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x792=IKPowWithIntegerCheck(sj5,-1);
if(!x792.valid){
continue;
}
IkReal x791=x792.value;
CheckValue<IkReal> x793=IKPowWithIntegerCheck(cj4,-1);
if(!x793.valid){
continue;
}
if( IKabs((new_r20*x791)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x791*(x793.value)*((((cj5*new_r20*sj4))+((new_r00*sj5)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r20*x791))+IKsqr((x791*(x793.value)*((((cj5*new_r20*sj4))+((new_r00*sj5))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((new_r20*x791), (x791*(x793.value)*((((cj5*new_r20*sj4))+((new_r00*sj5))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x794=IKsin(j6);
IkReal x795=((1.0)*x794);
IkReal x796=IKcos(j6);
IkReal x797=((1.0)*x796);
IkReal x798=((-1.0)*x797);
IkReal x799=(cj4*x794);
IkReal x800=(cj4*x797);
IkReal x801=(sj4*x794);
IkReal x802=(cj4*new_r10);
IkReal x803=((1.0)*sj4);
IkReal x804=(new_r00*x803);
IkReal x805=(cj4*new_r11);
IkReal x806=(new_r01*x803);
evalcond[0]=((((-1.0)*sj5*x795))+new_r20);
evalcond[1]=((((-1.0)*sj5*x797))+new_r21);
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x794);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+x798);
evalcond[4]=(((cj5*sj4*x796))+new_r01+x799);
evalcond[5]=(((cj5*x801))+(((-1.0)*x800))+new_r00);
evalcond[6]=(x801+new_r11+(((-1.0)*cj5*x800)));
evalcond[7]=((((-1.0)*cj5*x795))+x802+(((-1.0)*x804)));
evalcond[8]=((((-1.0)*cj5*x797))+(((-1.0)*x806))+x805);
evalcond[9]=((((-1.0)*cj5*x799))+new_r10+(((-1.0)*x796*x803)));
evalcond[10]=(((new_r20*sj5))+(((-1.0)*cj5*x804))+((cj5*x802))+(((-1.0)*x795)));
evalcond[11]=((((-1.0)*cj5*x806))+((cj5*x805))+((new_r21*sj5))+x798);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x807 = IKatan2WithCheck(IkReal(new_r20),new_r21,IKFAST_ATAN2_MAGTHRESH);
if(!x807.valid){
continue;
}
CheckValue<IkReal> x808=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x808.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x807.value)+(((1.5707963267949)*(x808.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x809=IKsin(j6);
IkReal x810=((1.0)*x809);
IkReal x811=IKcos(j6);
IkReal x812=((1.0)*x811);
IkReal x813=((-1.0)*x812);
IkReal x814=(cj4*x809);
IkReal x815=(cj4*x812);
IkReal x816=(sj4*x809);
IkReal x817=(cj4*new_r10);
IkReal x818=((1.0)*sj4);
IkReal x819=(new_r00*x818);
IkReal x820=(cj4*new_r11);
IkReal x821=(new_r01*x818);
evalcond[0]=((((-1.0)*sj5*x810))+new_r20);
evalcond[1]=((((-1.0)*sj5*x812))+new_r21);
evalcond[2]=(x809+((cj4*new_r01))+((new_r11*sj4)));
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+x813);
evalcond[4]=(((cj5*sj4*x811))+x814+new_r01);
evalcond[5]=(((cj5*x816))+(((-1.0)*x815))+new_r00);
evalcond[6]=((((-1.0)*cj5*x815))+x816+new_r11);
evalcond[7]=((((-1.0)*cj5*x810))+(((-1.0)*x819))+x817);
evalcond[8]=((((-1.0)*cj5*x812))+(((-1.0)*x821))+x820);
evalcond[9]=(new_r10+(((-1.0)*x811*x818))+(((-1.0)*cj5*x814)));
evalcond[10]=(((new_r20*sj5))+(((-1.0)*cj5*x819))+((cj5*x817))+(((-1.0)*x810)));
evalcond[11]=(((cj5*x820))+((new_r21*sj5))+x813+(((-1.0)*cj5*x821)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x822 = IKatan2WithCheck(IkReal(new_r20),new_r21,IKFAST_ATAN2_MAGTHRESH);
if(!x822.valid){
continue;
}
CheckValue<IkReal> x823=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x823.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x822.value)+(((1.5707963267949)*(x823.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
IkReal x824=((1.0)*sj5);
evalcond[0]=((((-1.0)*x824*(IKsin(j6))))+new_r20);
evalcond[1]=((((-1.0)*x824*(IKcos(j6))))+new_r21);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
IkReal x825=((1.0)*cj2);
IkReal x826=(cj1*sj2);
IkReal x827=(sj1*sj2);
IkReal x828=((1.0)*sj2*sj3);
IkReal x829=(cj3*sj1);
IkReal x830=(cj1*sj3);
IkReal x831=((((-1.0)*x825*x830))+x829);
IkReal x832=((1.0)*cj1*cj3);
IkReal x833=(sj1*sj3);
IkReal x834=x256;
IkReal x835=((1.0)*cj3*sj2);
IkReal x836=(x830+(((-1.0)*x825*x829)));
IkReal x837=x259;
new_r00=((((-1.0)*r20*x825))+((r00*x826))+((r10*x827)));
new_r01=(((r11*x827))+(((-1.0)*r21*x825))+((r01*x826)));
new_r02=((((-1.0)*r22*x825))+((r02*x826))+((r12*x827)));
new_r10=(((r10*x834))+((r00*x831))+(((-1.0)*r20*x828)));
new_r11=(((r11*x834))+(((-1.0)*r21*x828))+((r01*x831)));
new_r12=(((r02*x831))+(((-1.0)*r22*x828))+((r12*x834)));
new_r20=(((r10*x836))+(((-1.0)*r20*x835))+((r00*x837)));
new_r21=(((r01*x837))+((r11*x836))+(((-1.0)*r21*x835)));
new_r22=(((r12*x836))+(((-1.0)*r22*x835))+((r02*x837)));
IkReal x838=(cj1*r02);
IkReal x839=(r12*sj1);
IkReal x840=(cj2*sj3);
j4eval[0]=sj5;
j4eval[1]=IKsign(sj5);
j4eval[2]=((IKabs(((((-1.0)*(1.0)*cj2*r22))+((sj2*x838))+((sj2*x839)))))+(IKabs((((r22*sj2*sj3))+((x838*x840))+((x839*x840))+((cj1*cj3*r12))+(((-1.0)*(1.0)*cj3*r02*sj1))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
IkReal x841=((1.0)*cj2);
IkReal x842=(cj1*sj2);
IkReal x843=(sj1*sj2);
IkReal x844=((1.0)*sj2*sj3);
IkReal x845=(cj3*sj1);
IkReal x846=(cj1*sj3);
IkReal x847=(x845+(((-1.0)*x841*x846)));
IkReal x848=((1.0)*cj1*cj3);
IkReal x849=(sj1*sj3);
IkReal x850=x256;
IkReal x851=((1.0)*cj3*sj2);
IkReal x852=(x846+(((-1.0)*x841*x845)));
IkReal x853=x259;
new_r00=(((r00*x842))+(((-1.0)*r20*x841))+((r10*x843)));
new_r01=(((r11*x843))+(((-1.0)*r21*x841))+((r01*x842)));
new_r02=((((-1.0)*r22*x841))+((r12*x843))+((r02*x842)));
new_r10=(((r00*x847))+((r10*x850))+(((-1.0)*r20*x844)));
new_r11=(((r11*x850))+((r01*x847))+(((-1.0)*r21*x844)));
new_r12=((((-1.0)*r22*x844))+((r02*x847))+((r12*x850)));
new_r20=(((r00*x853))+(((-1.0)*r20*x851))+((r10*x852)));
new_r21=(((r11*x852))+(((-1.0)*r21*x851))+((r01*x853)));
new_r22=(((r02*x853))+(((-1.0)*r22*x851))+((r12*x852)));
j4eval[0]=sj5;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x854 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r00*new_r02)))),(new_r00*new_r12),IKFAST_ATAN2_MAGTHRESH);
if(!x854.valid){
continue;
}
CheckValue<IkReal> x855=IKPowWithIntegerCheck(IKsign((((new_r02*sj6))+((cj6*new_r12)))),-1);
if(!x855.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x854.value)+(((1.5707963267949)*(x855.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x856=IKcos(j4);
IkReal x857=IKsin(j4);
IkReal x858=((1.0)*x857);
IkReal x859=((1.0)*cj6);
IkReal x860=(((sj6*x857))+(((-1.0)*x856*x859)));
IkReal x861=((-1.0)*x859);
IkReal x862=((1.0)*sj6);
evalcond[0]=(((new_r12*x857))+((new_r02*x856)));
evalcond[1]=(((new_r01*x856))+sj6+((new_r11*x857)));
evalcond[2]=((((-1.0)*new_r02*x858))+((new_r12*x856)));
evalcond[3]=(((cj6*x857))+new_r01+((sj6*x856)));
evalcond[4]=(x860+new_r00);
evalcond[5]=(x860+new_r11);
evalcond[6]=(((new_r00*x856))+((new_r10*x857))+x861);
evalcond[7]=((((-1.0)*x857*x859))+new_r10+(((-1.0)*x856*x862)));
evalcond[8]=((((-1.0)*x862))+(((-1.0)*new_r00*x858))+((new_r10*x856)));
evalcond[9]=((((-1.0)*new_r01*x858))+x861+((new_r11*x856)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r12;
evalcond[3]=new_r02;
evalcond[4]=new_r20;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x863=IKPowWithIntegerCheck(IKsign((((new_r12*sj6))+((cj6*new_r02)))),-1);
if(!x863.valid){
continue;
}
CheckValue<IkReal> x864 = IKatan2WithCheck(IkReal((new_r01*new_r02)),((-1.0)*(((1.0)*new_r01*new_r12))),IKFAST_ATAN2_MAGTHRESH);
if(!x864.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x863.value)))+(x864.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[10];
IkReal x865=IKcos(j4);
IkReal x866=IKsin(j4);
IkReal x867=((1.0)*x866);
IkReal x868=(sj6*x866);
IkReal x869=((1.0)*cj6);
IkReal x870=((((-1.0)*x866*x869))+((sj6*x865)));
evalcond[0]=(((new_r12*x866))+((new_r02*x865)));
evalcond[1]=(((new_r01*x865))+((new_r11*x866))+sj6);
evalcond[2]=((((-1.0)*new_r02*x867))+((new_r12*x865)));
evalcond[3]=(x868+((cj6*x865))+new_r11);
evalcond[4]=(new_r01+x870);
evalcond[5]=((((-1.0)*new_r00*x867))+sj6+((new_r10*x865)));
evalcond[6]=(((new_r11*x865))+cj6+(((-1.0)*new_r01*x867)));
evalcond[7]=(new_r10+x870);
evalcond[8]=(((new_r10*x866))+(((-1.0)*x869))+((new_r00*x865)));
evalcond[9]=((((-1.0)*x868))+new_r00+(((-1.0)*x865*x869)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x872=IKPowWithIntegerCheck(sj5,-1);
if(!x872.valid){
continue;
}
IkReal x871=x872.value;
CheckValue<IkReal> x873=IKPowWithIntegerCheck(new_r11,-1);
if(!x873.valid){
continue;
}
if( IKabs((x871*(x873.value)*(((((-1.0)*(1.0)*sj5*sj6))+((new_r01*new_r12)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r12*x871)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x871*(x873.value)*(((((-1.0)*(1.0)*sj5*sj6))+((new_r01*new_r12))))))+IKsqr(((-1.0)*new_r12*x871))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x871*(x873.value)*(((((-1.0)*(1.0)*sj5*sj6))+((new_r01*new_r12))))), ((-1.0)*new_r12*x871));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x874=IKcos(j4);
IkReal x875=IKsin(j4);
IkReal x876=((1.0)*x875);
IkReal x877=(new_r12*x874);
IkReal x878=(new_r02*x876);
IkReal x879=((1.0)*cj6);
IkReal x880=((-1.0)*x879);
IkReal x881=(sj6*x875);
IkReal x882=(cj5*x879);
IkReal x883=((1.0)*sj6);
IkReal x884=(cj5*x883);
IkReal x885=(new_r10*x874);
IkReal x886=(new_r00*x876);
IkReal x887=(new_r11*x874);
IkReal x888=(new_r01*x876);
IkReal x889=((1.0)*cj5*x875);
IkReal x890=((1.0)*cj5);
evalcond[0]=(((sj5*x874))+new_r12);
evalcond[1]=((((-1.0)*sj5*x876))+new_r02);
evalcond[2]=(((new_r02*x874))+((new_r12*x875)));
evalcond[3]=(((new_r01*x874))+sj6+((new_r11*x875)));
evalcond[4]=(sj5+x877+(((-1.0)*x878)));
evalcond[5]=(((sj6*x874))+((cj5*cj6*x875))+new_r01);
evalcond[6]=(((new_r10*x875))+x880+((new_r00*x874)));
evalcond[7]=(((cj5*x881))+(((-1.0)*x874*x879))+new_r00);
evalcond[8]=((((-1.0)*x874*x882))+x881+new_r11);
evalcond[9]=((((-1.0)*x874*x884))+new_r10+(((-1.0)*x875*x879)));
evalcond[10]=((((-1.0)*x884))+(((-1.0)*x886))+x885);
evalcond[11]=((((-1.0)*x888))+x887+(((-1.0)*x882)));
evalcond[12]=(((new_r22*sj5))+(((-1.0)*new_r02*x889))+((cj5*x877)));
evalcond[13]=((((-1.0)*new_r20*x890))+(((-1.0)*sj5*x886))+((sj5*x885)));
evalcond[14]=((((-1.0)*sj5*x888))+((sj5*x887))+(((-1.0)*new_r21*x890)));
evalcond[15]=((1.0)+(((-1.0)*sj5*x878))+((sj5*x877))+(((-1.0)*new_r22*x890)));
evalcond[16]=(((new_r20*sj5))+((cj5*x885))+(((-1.0)*x883))+(((-1.0)*new_r00*x889)));
evalcond[17]=((((-1.0)*new_r01*x889))+x880+((new_r21*sj5))+((cj5*x887)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x891=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x891.valid){
continue;
}
CheckValue<IkReal> x892 = IKatan2WithCheck(IkReal(new_r02),((-1.0)*(((1.0)*new_r12))),IKFAST_ATAN2_MAGTHRESH);
if(!x892.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x891.value)))+(x892.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x893=IKcos(j4);
IkReal x894=IKsin(j4);
IkReal x895=((1.0)*x894);
IkReal x896=(new_r12*x893);
IkReal x897=(new_r02*x895);
IkReal x898=((1.0)*cj6);
IkReal x899=((-1.0)*x898);
IkReal x900=(sj6*x894);
IkReal x901=(cj5*x898);
IkReal x902=((1.0)*sj6);
IkReal x903=(cj5*x902);
IkReal x904=(new_r10*x893);
IkReal x905=(new_r00*x895);
IkReal x906=(new_r11*x893);
IkReal x907=(new_r01*x895);
IkReal x908=((1.0)*cj5*x894);
IkReal x909=((1.0)*cj5);
evalcond[0]=(((sj5*x893))+new_r12);
evalcond[1]=((((-1.0)*sj5*x895))+new_r02);
evalcond[2]=(((new_r12*x894))+((new_r02*x893)));
evalcond[3]=(((new_r01*x893))+sj6+((new_r11*x894)));
evalcond[4]=((((-1.0)*x897))+sj5+x896);
evalcond[5]=(((cj5*cj6*x894))+((sj6*x893))+new_r01);
evalcond[6]=(((new_r10*x894))+((new_r00*x893))+x899);
evalcond[7]=((((-1.0)*x893*x898))+((cj5*x900))+new_r00);
evalcond[8]=((((-1.0)*x893*x901))+x900+new_r11);
evalcond[9]=((((-1.0)*x894*x898))+(((-1.0)*x893*x903))+new_r10);
evalcond[10]=(x904+(((-1.0)*x903))+(((-1.0)*x905)));
evalcond[11]=((((-1.0)*x901))+x906+(((-1.0)*x907)));
evalcond[12]=((((-1.0)*new_r02*x908))+((cj5*x896))+((new_r22*sj5)));
evalcond[13]=((((-1.0)*sj5*x905))+((sj5*x904))+(((-1.0)*new_r20*x909)));
evalcond[14]=(((sj5*x906))+(((-1.0)*sj5*x907))+(((-1.0)*new_r21*x909)));
evalcond[15]=((1.0)+(((-1.0)*new_r22*x909))+((sj5*x896))+(((-1.0)*sj5*x897)));
evalcond[16]=((((-1.0)*new_r00*x908))+((new_r20*sj5))+(((-1.0)*x902))+((cj5*x904)));
evalcond[17]=(((new_r21*sj5))+(((-1.0)*new_r01*x908))+((cj5*x906))+x899);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j1;
vinfos[0].indices[0] = _ij1[0];
vinfos[0].indices[1] = _ij1[1];
vinfos[0].maxsolutions = _nj1;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j2;
vinfos[1].indices[0] = _ij2[0];
vinfos[1].indices[1] = _ij2[1];
vinfos[1].maxsolutions = _nj2;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j3;
vinfos[2].indices[0] = _ij3[0];
vinfos[2].indices[1] = _ij3[1];
vinfos[2].maxsolutions = _nj3;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j4;
vinfos[3].indices[0] = _ij4[0];
vinfos[3].indices[1] = _ij4[1];
vinfos[3].maxsolutions = _nj4;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j5;
vinfos[4].indices[0] = _ij5[0];
vinfos[4].indices[1] = _ij5[1];
vinfos[4].maxsolutions = _nj5;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j6;
vinfos[5].indices[0] = _ij6[0];
vinfos[5].indices[1] = _ij6[1];
vinfos[5].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - sia5 (960d2d9ecfe14398ec1254f240543b9e)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
